# é”™è¯¯è¾¹ç•Œ (Error Boundaries) - ä¼˜é›…çš„é”™è¯¯å¤„ç†

import { Tabs, TabItem } from '@docusaurus/theme-common';

é”™è¯¯è¾¹ç•Œæ˜¯Reactä¸­ç”¨äºæ•è·JavaScripté”™è¯¯å¹¶ä¼˜é›…åœ°å±•ç¤ºé™çº§UIçš„ç»„ä»¶æ¨¡å¼ã€‚å®ƒä»¬èƒ½å¤Ÿæ•è·å­ç»„ä»¶æ ‘ä¸­çš„é”™è¯¯ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯ï¼Œå¹¶æ˜¾ç¤ºä¸€ä¸ªé™çº§çš„UIè€Œä¸æ˜¯æ•´ä¸ªåº”ç”¨å´©æºƒã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨é”™è¯¯è¾¹ç•Œçš„æ¦‚å¿µã€å®ç°æ–¹å¼ã€æœ€ä½³å®è·µå’Œä½¿ç”¨åœºæ™¯ã€‚

## æœ¬ç« å­¦ä¹ ç›®æ ‡

- ç†è§£é”™è¯¯è¾¹ç•Œçš„æ¦‚å¿µå’Œä½œç”¨
- æŒæ¡é”™è¯¯è¾¹ç•Œçš„å®ç°æ–¹å¼
- å­¦ä¼šåˆ›å»ºå¯å¤ç”¨çš„é”™è¯¯è¾¹ç•Œç»„ä»¶
- ç†è§£é”™è¯¯è¾¹ç•Œçš„ç”Ÿå‘½å‘¨æœŸæ–¹æ³•
- æŒæ¡é”™è¯¯è¾¹ç•Œä¸é”™è¯¯å¤„ç†çš„å…³ç³»
- å­¦ä¼šè®°å½•å’Œä¸ŠæŠ¥é”™è¯¯ä¿¡æ¯
- ç†è§£é”™è¯¯è¾¹ç•Œçš„å±€é™æ€§å’Œæ³¨æ„äº‹é¡¹
- æŒæ¡é”™è¯¯è¾¹ç•Œçš„å®é™…åº”ç”¨åœºæ™¯

---

## 1. ä»€ä¹ˆæ˜¯é”™è¯¯è¾¹ç•Œï¼Ÿ

é”™è¯¯è¾¹ç•Œæ˜¯Reactç»„ä»¶ï¼Œå®ƒèƒ½å¤Ÿæ•è·å­ç»„ä»¶æ ‘ä¸­å‘ç”Ÿçš„JavaScripté”™è¯¯ï¼Œè®°å½•è¿™äº›é”™è¯¯ï¼Œå¹¶æ˜¾ç¤ºä¸€ä¸ªé™çº§çš„UIè€Œä¸æ˜¯æ•´ä¸ªç»„ä»¶æ ‘å´©æºƒã€‚é”™è¯¯è¾¹ç•Œèƒ½å¤Ÿæ•è·æ¸²æŸ“è¿‡ç¨‹ä¸­ã€ç”Ÿå‘½å‘¨æœŸæ–¹æ³•ä¸­ä»¥åŠæ•´ä¸ªç»„ä»¶æ ‘çš„æ„é€ å‡½æ•°ä¸­å‘ç”Ÿçš„é”™è¯¯ã€‚

<Box style={{ padding: '20px', background: '#e3f2fd', borderRadius: '8px', margin: '20px 0' }}>
  <h4 style={{ margin: 0, color: '#1976d2' }}>ğŸ’¡ æ ¸å¿ƒæ¦‚å¿µ</h4>
  <p style={{ margin: '10px 0 0 0' }}>
    <strong>é”™è¯¯è¾¹ç•Œ</strong>æ˜¯Reactç±»ç»„ä»¶ç‰¹æœ‰çš„æ¨¡å¼ï¼Œä½¿ç”¨<strong>getDerivedStateFromError</strong>æˆ–<strong>componentDidCatch</strong>ç”Ÿå‘½å‘¨æœŸæ–¹æ³•æ•è·å­ç»„ä»¶é”™è¯¯ã€‚å‡½æ•°ç»„ä»¶éœ€è¦ä½¿ç”¨<strong>ErrorBoundary</strong>ç±»ç»„ä»¶åŒ…è£…ã€‚
  </p>
</Box>

<CodeBlock>

```jsx
// åŸºç¡€é”™è¯¯è¾¹ç•Œ
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    // æ›´æ–°stateä½¿ä¸‹ä¸€æ¬¡æ¸²æŸ“æ˜¾ç¤ºé™çº§UI
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // è®°å½•é”™è¯¯ä¿¡æ¯
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // é™çº§UI
      return (
        <div>
          <h2>Something went wrong.</h2>
          <p>{this.state.error?.message}</p>
          <button onClick={() => window.location.reload()}>
            Reload page
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// ä½¿ç”¨
<ErrorBoundary>
  <MyComponent />
</ErrorBoundary>
```

</CodeBlock>

### 1.1 é”™è¯¯è¾¹ç•Œè§£å†³çš„é—®é¢˜

<Grid>

<div>
  <h4>æ²¡æœ‰é”™è¯¯è¾¹ç•Œçš„é—®é¢˜</h4>
  <ul>
    <li>âŒ å­ç»„ä»¶é”™è¯¯å¯¼è‡´æ•´ä¸ªåº”ç”¨å´©æºƒ</li>
    <li>âŒ ç©ºç™½é¡µé¢ï¼Œç”¨æˆ·ä½“éªŒå·®</li>
    <li>âŒ éš¾ä»¥è°ƒè¯•å’Œå®šä½é”™è¯¯</li>
    <li>âŒ æ— æ³•æ¢å¤ï¼Œéœ€è¦åˆ·æ–°é¡µé¢</li>
    <li>âŒ ç”Ÿäº§ç¯å¢ƒé”™è¯¯ä¸å¯è§</li>
  </ul>
</div>

<div>
  <h4>é”™è¯¯è¾¹ç•Œçš„è§£å†³æ–¹æ¡ˆ</h4>
  <ul>
    <li>âœ… å±€éƒ¨é”™è¯¯ä¸å½±å“æ•´ä¸ªåº”ç”¨</li>
    <li>âœ… æ˜¾ç¤ºå‹å¥½çš„é”™è¯¯æç¤º</li>
    <li>âœ… è®°å½•é”™è¯¯ä¿¡æ¯ç”¨äºè°ƒè¯•</li>
    <li>âœ… æä¾›æ¢å¤æˆ–é‡è¯•é€‰é¡¹</li>
    <li>âœ… é”™è¯¯ä¸ŠæŠ¥å’Œåˆ†æ</li>
  </ul>
</div>

</Grid>

### 1.2 é”™è¯¯è¾¹ç•Œçš„ç»„æˆ

<CodeBlock>

```jsx
// é”™è¯¯è¾¹ç•Œçš„æ ¸å¿ƒè¦ç´ 
1. çŠ¶æ€ç®¡ç†
   - hasError: å¸ƒå°”å€¼ï¼Œè¡¨ç¤ºæ˜¯å¦å‘ç”Ÿé”™è¯¯
   - error: é”™è¯¯å¯¹è±¡
   - errorInfo: é”™è¯¯å †æ ˆä¿¡æ¯

2. é™æ€æ–¹æ³•
   - getDerivedStateFromError(error)
     * æ¥æ”¶é”™è¯¯å¯¹è±¡
     * è¿”å›æ–°çš„stateçŠ¶æ€
     * ç”¨äºæ›´æ–°stateæ˜¾ç¤ºé™çº§UI

3. ç”Ÿå‘½å‘¨æœŸæ–¹æ³•
   - componentDidCatch(error, errorInfo)
     * æ¥æ”¶é”™è¯¯å’Œé”™è¯¯ä¿¡æ¯
     * è®°å½•é”™è¯¯æ—¥å¿—
     * å‘é€é”™è¯¯ä¸ŠæŠ¥
     * æ¸…ç†èµ„æº

4. æ¸²æŸ“æ–¹æ³•
   - render()
     * æ£€æŸ¥hasErrorçŠ¶æ€
     * è¿”å›é™çº§UIæˆ–æ­£å¸¸å­ç»„ä»¶
```

</CodeBlock>

---

## 2. é”™è¯¯è¾¹ç•Œå®ç°åŸºç¡€

### 2.1 åŸºç¡€é”™è¯¯è¾¹ç•Œ

<CodeBlock>

```jsx
// åŸºç¡€é”™è¯¯è¾¹ç•Œç»„ä»¶
import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    };
  }

  static getDerivedStateFromError(error) {
    // æ›´æ–°stateä»¥æ˜¾ç¤ºé™çº§UI
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // è®°å½•é”™è¯¯è¯¦æƒ…
    console.error('ErrorBoundary caught an error:', error, errorInfo);

    this.setState({
      error: error,
      errorInfo: errorInfo
    });

    // å¯é€‰ï¼šå‘é€é”™è¯¯åˆ°é”™è¯¯ä¸ŠæŠ¥æœåŠ¡
    // logErrorToService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      const { fallback: Fallback } = this.props;

      // ä½¿ç”¨è‡ªå®šä¹‰é™çº§ç»„ä»¶æˆ–é»˜è®¤UI
      if (Fallback) {
        return (
          <Fallback
            error={this.state.error}
            retry={this.handleRetry}
          />
        );
      }

      return (
        <div style={{
          padding: '20px',
          border: '1px solid #e0e0e0',
          borderRadius: '8px',
          margin: '20px 0'
        }}>
          <h2>å‡ºé”™äº†</h2>
          <p>æŠ±æ­‰ï¼Œé¡µé¢é‡åˆ°äº†é”™è¯¯ã€‚è¯·å°è¯•åˆ·æ–°é¡µé¢ã€‚</p>
          <button onClick={this.handleRetry}>
            é‡è¯•
          </button>
        </div>
      );
    }

    return this.props.children;
  }

  handleRetry = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    });
  };
}

// ä½¿ç”¨
<ErrorBoundary>
  <MyComponent />
</ErrorBoundary>
```

</CodeBlock>

### 2.2 ä½¿ç”¨Propsè‡ªå®šä¹‰é™çº§UI

<CodeBlock>

```jsx
// æ”¯æŒè‡ªå®šä¹‰é™çº§ç»„ä»¶
class ErrorBoundary extends React.Component {
  // ... ç›¸åŒçš„é”™è¯¯å¤„ç†é€»è¾‘

  render() {
    const {
      hasError,
      error,
      errorInfo
    } = this.state;
    const {
      fallback: Fallback,
      onError,
      showDetails = false
    } = this.props;

    if (hasError) {
      // ä½¿ç”¨è‡ªå®šä¹‰é™çº§ç»„ä»¶
      if (Fallback) {
        return (
          <Fallback
            error={error}
            errorInfo={errorInfo}
            retry={this.handleRetry}
          />
        );
      }

      // é»˜è®¤é™çº§UI
      return (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <p>æˆ‘ä»¬é‡åˆ°äº†ä¸€ä¸ªé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚</p>

          {showDetails && error && (
            <details style={{ marginTop: '20px' }}>
              <summary>é”™è¯¯è¯¦æƒ…</summary>
              <pre style={{
                whiteSpace: 'pre-wrap',
                fontSize: '12px',
                marginTop: '10px'
              }}>
                {error.toString()}
              </pre>
            </details>
          )}

          <div style={{ marginTop: '20px' }}>
            <button onClick={this.handleRetry}>
              é‡æ–°å°è¯•
            </button>
            <button
              onClick={() => window.location.reload()}
              style={{ marginLeft: '10px' }}
            >
              åˆ·æ–°é¡µé¢
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

// è‡ªå®šä¹‰é™çº§ç»„ä»¶
const MyCustomFallback = ({ error, retry }) => (
  <div style={{
    padding: '40px',
    textAlign: 'center',
    background: '#fff3e0',
    borderRadius: '8px'
  }}>
    <h3>é¡µé¢æš‚æ—¶æ— æ³•è®¿é—®</h3>
    <p>è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•</p>
    <button onClick={retry}>
      é‡è¯•
    </button>
  </div>
);

// ä½¿ç”¨
<ErrorBoundary
  fallback={MyCustomFallback}
  onError={(error, errorInfo) => {
    // é”™è¯¯ä¸ŠæŠ¥
    console.log('Error reported:', error);
  }}
  showDetails={true}
>
  <MyComponent />
</ErrorBoundary>
```

</CodeBlock>

### 2.3 é”™è¯¯ä¸ŠæŠ¥é›†æˆ

<CodeBlock>

```jsx
// å¸¦é”™è¯¯ä¸ŠæŠ¥çš„é”™è¯¯è¾¹ç•Œ
class ErrorBoundaryWithLogging extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorId: null
    };
  }

  static getDerivedStateFromError(error) {
    return {
      hasError: true,
      error: error,
      errorId: Date.now().toString() // ç”Ÿæˆé”™è¯¯ID
    };
  }

  componentDidCatch(error, errorInfo) {
    const { onError, onErrorReport } = this.props;
    const errorDetails = {
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      timestamp: new Date().toISOString(),
      errorId: this.state.errorId,
      userAgent: navigator.userAgent,
      url: window.location.href
    };

    // è®°å½•åˆ°æ§åˆ¶å°
    console.error('Error caught by boundary:', errorDetails);

    // è°ƒç”¨é”™è¯¯å›è°ƒ
    onError?.(error, errorInfo);

    // å‘é€é”™è¯¯ä¸ŠæŠ¥
    if (onErrorReport) {
      onErrorReport(errorDetails);
    } else {
      // é»˜è®¤ä¸ŠæŠ¥é€»è¾‘
      this.reportError(errorDetails);
    }
  }

  reportError = async (errorDetails) => {
    try {
      // å‘é€åˆ°é”™è¯¯ç›‘æ§æœåŠ¡
      await fetch('/api/errors', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(errorDetails)
      });
    } catch (reportingError) {
      console.error('Failed to report error:', reportingError);
    }
  };

  render() {
    if (this.state.hasError) {
      const { fallback: Fallback } = this.props;
      const { errorId } = this.state;

      return (
        <div className="error-boundary">
          <h2>å‡ºé”™äº†</h2>
          <p>
            æŠ±æ­‰ï¼Œé¡µé¢é‡åˆ°é”™è¯¯ã€‚é”™è¯¯ID:
            <code>{errorId}</code>
          </p>
          <p>è¯·å°†æ­¤é”™è¯¯IDæä¾›ç»™æŠ€æœ¯æ”¯æŒå›¢é˜Ÿã€‚</p>
          <button onClick={this.handleRetry}>
            é‡è¯•
          </button>
        </div>
      );
    }

    return this.props.children;
  }

  handleRetry = () => {
    this.setState({
      hasError: false,
      error: null,
      errorId: null
    });
  };
}

// ä½¿ç”¨
<ErrorBoundaryWithLogging
  fallback={CustomFallback}
  onError={(error, errorInfo) => {
    // æœ¬åœ°é”™è¯¯å¤„ç†
    console.log('Local error handling');
  }}
  onErrorReport={(errorDetails) => {
    // è‡ªå®šä¹‰é”™è¯¯ä¸ŠæŠ¥
    console.log('Custom error reporting:', errorDetails);
  }}
>
  <MyComponent />
</ErrorBoundaryWithLogging>
```

</CodeBlock>

---

## 3. é«˜çº§é”™è¯¯è¾¹ç•Œæ¨¡å¼

### 3.1 å¤šçº§é”™è¯¯è¾¹ç•Œ

<CodeBlock>

```jsx
// é¡µé¢çº§é”™è¯¯è¾¹ç•Œ
class PageErrorBoundary extends React.Component {
  render() {
    return (
      <ErrorBoundary
        fallback={({ error, retry }) => (
          <div style={{ padding: '40px' }}>
            <h1>é¡µé¢åŠ è½½å¤±è´¥</h1>
            <p>æ­¤é¡µé¢é‡åˆ°äº†é—®é¢˜</p>
            <button onClick={retry}>é‡è¯•</button>
          </div>
        )}
      >
        {this.props.children}
      </ErrorBoundary>
    );
  }
}

// ç»„ä»¶çº§é”™è¯¯è¾¹ç•Œ
class ComponentErrorBoundary extends React.Component {
  render() {
    return (
      <ErrorBoundary
        fallback={({ error }) => (
          <div style={{ padding: '20px', background: '#ffebee' }}>
            <p>ç»„ä»¶åŠ è½½å¤±è´¥</p>
          </div>
        )}
      >
        {this.props.children}
      </ErrorBoundary>
    );
  }
}

// åŒºåŸŸçº§é”™è¯¯è¾¹ç•Œ
class SectionErrorBoundary extends React.Component {
  render() {
    return (
      <ErrorBoundary
        fallback={() => (
          <div style={{ padding: '10px' }}>
            <p>æ­¤éƒ¨åˆ†æš‚æ—¶ä¸å¯ç”¨</p>
          </div>
        )}
      >
        {this.props.children}
      </ErrorBoundary>
    );
  }
}

// ä½¿ç”¨å¤šå±‚é”™è¯¯è¾¹ç•Œ
function App() {
  return (
    <PageErrorBoundary>
      <Header />
      <ComponentErrorBoundary>
        <MainContent />
      </ComponentErrorBoundary>
      <SectionErrorBoundary>
        <Sidebar />
      </SectionErrorBoundary>
      <Footer />
    </PageErrorBoundary>
  );
}
```

</CodeBlock>

### 3.2 æ¡ä»¶é”™è¯¯è¾¹ç•Œ

<CodeBlock>

```jsx
// æ ¹æ®æ¡ä»¶å¯ç”¨é”™è¯¯è¾¹ç•Œ
class ConditionalErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false
    };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // åªåœ¨å¯ç”¨æ—¶è®°å½•é”™è¯¯
    if (this.props.enableLogging) {
      console.error('ErrorBoundary:', error, errorInfo);
    }
  }

  render() {
    const {
      enableErrorBoundary = true,
      children,
      fallback
    } = this.props;

    if (!enableErrorBoundary) {
      return children;
    }

    if (this.state.hasError) {
      if (fallback) {
        return <>{fallback}</>;
      }

      return <div>å‡ºé”™äº†</div>;
    }

    return children;
  }
}

// å¼€å‘å’Œç”Ÿäº§ç¯å¢ƒä½¿ç”¨ä¸åŒç­–ç•¥
const App = () => {
  const isDevelopment = process.env.NODE_ENV === 'development';

  return (
    <ConditionalErrorBoundary
      enableErrorBoundary={isDevelopment}
      fallback={<div>Something went wrong</div>}
    >
      <MyComponent />
    </ConditionalErrorBoundary>
  );
};

// åŸºäºç”¨æˆ·ç±»å‹å¯ç”¨é”™è¯¯è¾¹ç•Œ
const UserApp = ({ userType }) => {
  const isPremiumUser = userType === 'premium';

  return (
    <ConditionalErrorBoundary
      enableErrorBoundary={!isPremiumUser} // å…è´¹ç”¨æˆ·çœ‹åˆ°é”™è¯¯è¾¹ç•Œï¼Œä»˜è´¹ç”¨æˆ·ä¸çœ‹åˆ°
      fallback={
        <div>
          <h3>åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨</h3>
          <p>å‡çº§åˆ°ä»˜è´¹ç‰ˆæœ¬ä»¥è·å¾—æ›´å¥½çš„ä½“éªŒ</p>
        </div>
      }
    >
      <AdvancedFeature />
    </ConditionalErrorBoundary>
  );
};
```

</CodeBlock>

### 3.3 é”™è¯¯è¾¹ç•Œç»„åˆ

<CodeBlock>

```jsx
// é”™è¯¯è¾¹ç•Œç»„åˆå™¨
function withErrorBoundary(
  WrappedComponent,
  errorBoundaryProps = {}
) {
  return function EnhancedComponent(props) {
    return (
      <ErrorBoundary {...errorBoundaryProps}>
        <WrappedComponent {...props} />
      </ErrorBoundary>
    );
  };
}

// ä½¿ç”¨é«˜é˜¶ç»„ä»¶æ–¹å¼
const EnhancedUserList = withErrorBoundary(UserList, {
  fallback: ({ error, retry }) => (
    <div>
      <p>ç”¨æˆ·åˆ—è¡¨åŠ è½½å¤±è´¥</p>
      <button onClick={retry}>é‡è¯•</button>
    </div>
  ),
  onErrorReport: (error) => {
    console.log('UserList error:', error);
  }
});

// é”™è¯¯è¾¹ç•Œ Hookï¼ˆä»…ç”¨äºç±»ç»„ä»¶åŒ…è£…ï¼‰
function useErrorHandler() {
  return {
    captureError: (error, context) => {
      console.error('Manual error capture:', error, context);
      // å¯ä»¥å‘é€åˆ°é”™è¯¯ç›‘æ§æœåŠ¡
    }
  };
}

// åœ¨ç±»ç»„ä»¶ä¸­ä½¿ç”¨é”™è¯¯å¤„ç† Hook
class MyComponent extends React.Component {
  componentDidMount() {
    this.errorHandler = useErrorHandler();
  }

  handleDataFetch = async () => {
    try {
      await fetchData();
    } catch (error) {
      this.errorHandler.captureError(error, {
        component: 'MyComponent',
        action: 'handleDataFetch'
      });
    }
  };

  render() {
    return <div>My Component</div>;
  }
}
```

</CodeBlock>

### 3.4 é”™è¯¯æ¢å¤æœºåˆ¶

<CodeBlock>

```jsx
// æ”¯æŒé”™è¯¯æ¢å¤çš„é”™è¯¯è¾¹ç•Œ
class RecoverableErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      retryCount: 0
    };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    const { onError, maxRetries = 3 } = this.props;
    const { retryCount } = this.state;

    this.setState({
      error,
      errorInfo
    });

    // è®°å½•é”™è¯¯
    onError?.(error, errorInfo, retryCount);

    // è‡ªåŠ¨é‡è¯•é€»è¾‘
    if (retryCount < maxRetries) {
      setTimeout(() => {
        this.handleRetry();
      }, 1000 * (retryCount + 1)); // é€’å¢å»¶è¿Ÿ
    }
  }

  handleRetry = () => {
    this.setState(prevState => ({
      hasError: false,
      error: null,
      errorInfo: null,
      retryCount: prevState.retryCount + 1
    }));
  };

  handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
      retryCount: 0
    });
  };

  render() {
    const {
      hasError,
      error,
      errorInfo,
      retryCount
    } = this.state;
    const {
      fallback: Fallback,
      maxRetries = 3,
      autoRetry = false
    } = this.props;

    if (hasError) {
      // è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°
      if (retryCount >= maxRetries) {
        return (
          <div>
            <h2>å¤šæ¬¡é‡è¯•åä»å¤±è´¥</h2>
            <p>è¯·å°è¯•åˆ·æ–°é¡µé¢æˆ–è”ç³»æŠ€æœ¯æ”¯æŒ</p>
            <div>
              <button onClick={this.handleRetry}>
                æ‰‹åŠ¨é‡è¯•
              </button>
              <button onClick={() => window.location.reload()}>
                åˆ·æ–°é¡µé¢
              </button>
            </div>
          </div>
        );
      }

      // è‡ªåŠ¨é‡è¯•ä¸­
      if (autoRetry) {
        return (
          <div style={{ textAlign: 'center', padding: '20px' }}>
            <p>é‡è¯•ä¸­... ({retryCount + 1}/{maxRetries})</p>
            <div>â³</div>
          </div>
        );
      }

      // ä½¿ç”¨è‡ªå®šä¹‰é™çº§ç»„ä»¶
      if (Fallback) {
        return (
          <Fallback
            error={error}
            retryCount={retryCount}
            maxRetries={maxRetries}
            onRetry={this.handleRetry}
            onReset={this.handleReset}
          />
        );
      }

      // é»˜è®¤é™çº§UI
      return (
        <div>
          <h2>å‡ºé”™äº†</h2>
          <p>å°è¯•äº† {retryCount} æ¬¡</p>
          <button onClick={this.handleRetry}>
            é‡è¯•
          </button>
          <button onClick={this.handleReset}>
            é‡ç½®
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// è‡ªå®šä¹‰é™çº§ç»„ä»¶
const CustomErrorFallback = ({
  error,
  retryCount,
  maxRetries,
  onRetry,
  onReset
}) => (
  <div style={{
    padding: '40px',
    background: '#fff',
    border: '2px solid #e74c3c',
    borderRadius: '8px',
    textAlign: 'center'
  }}>
    <h2 style={{ color: '#e74c3c' }}>ğŸ˜” å‡ºé”™äº†</h2>
    <p>æˆ‘ä»¬æ­£åœ¨åŠªåŠ›ä¿®å¤è¿™ä¸ªé—®é¢˜</p>
    <p>é‡è¯•æ¬¡æ•°: {retryCount}/{maxRetries}</p>
    <div style={{ marginTop: '20px' }}>
      <button onClick={onRetry} style={{ marginRight: '10px' }}>
        ğŸ”„ é‡è¯•
      </button>
      <button onClick={onReset}>
        ğŸ  è¿”å›é¦–é¡µ
      </button>
    </div>
  </div>
);

// ä½¿ç”¨
<RecoverableErrorBoundary
  fallback={CustomErrorFallback}
  maxRetries={5}
  autoRetry={true}
  onError={(error, errorInfo, retryCount) => {
    console.log(`Attempt ${retryCount}:`, error);
  }}
>
  <UnreliableComponent />
</RecoverableErrorBoundary>
```

</CodeBlock>

---

## 4. é”™è¯¯è¾¹ç•Œå®é™…åº”ç”¨

### 4.1 è·¯ç”±çº§é”™è¯¯è¾¹ç•Œ

<CodeBlock>

```jsx
// è·¯ç”±é”™è¯¯è¾¹ç•Œ
class RouteErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null
    };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    const { history, location } = this.props;

    // è®°å½•è·¯ç”±é”™è¯¯
    console.error('Route error:', {
      error: error.message,
      path: location.pathname,
      stack: error.stack
    });

    // å¯é€‰ï¼šè·³è½¬åˆ°é”™è¯¯é¡µé¢
    // history.push('/error');
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{ padding: '40px', textAlign: 'center' }}>
          <h1>é¡µé¢åŠ è½½å¤±è´¥</h1>
          <p>æŠ±æ­‰ï¼Œæ­¤é¡µé¢é‡åˆ°é—®é¢˜</p>
          <button onClick={() => window.location.href = '/'}>
            è¿”å›é¦–é¡µ
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// React Router é›†æˆ
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route
          path="/"
          element={
            <RouteErrorBoundary>
              <HomePage />
            </RouteErrorBoundary>
          }
        />
        <Route
          path="/dashboard"
          element={
            <RouteErrorBoundary>
              <Dashboard />
            </RouteErrorBoundary>
          }
        />
      </Routes>
    </BrowserRouter>
  );
}

// æˆ–è€…ä¸ºæ‰€æœ‰è·¯ç”±æ·»åŠ é”™è¯¯è¾¹ç•Œ
function ProtectedRoute({ children }) {
  return (
    <ErrorBoundary
      fallback={({ error, retry }) => (
        <div>
          <h1>éœ€è¦è®¤è¯</h1>
          <p>è¯·å…ˆç™»å½•</p>
        </div>
      )}
    >
      <RouteErrorBoundary>
        {children}
      </RouteErrorBoundary>
    </ErrorBoundary>
  );
}
```

</CodeBlock>

### 4.2 å¼‚æ­¥ç»„ä»¶é”™è¯¯å¤„ç†

<CodeBlock>

```jsx
// é”™è¯¯è¾¹ç•Œä¸Suspenseç»“åˆ
class SuspenseErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null
    };
  }

  static getDerivedStateFromError(error) {
    // å°†é”™è¯¯è®¾ç½®ä¸ºçŠ¶æ€ï¼Œä»¥ä¾¿Suspenseå¯ä»¥å¤„ç†
    if (error.name === 'ChunkLoadError') {
      window.location.reload(); // é‡æ–°åŠ è½½é¡µé¢
      return null;
    }
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    if (error.name !== 'ChunkLoadError') {
      console.error('Suspense error:', error, errorInfo);
    }
  }

  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h2>ç»„ä»¶åŠ è½½å¤±è´¥</h2>
          <button onClick={() => window.location.reload()}>
            é‡æ–°åŠ è½½
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// æ‡’åŠ è½½ç»„ä»¶ä¸é”™è¯¯è¾¹ç•Œ
const LazyComponent = React.lazy(() => import('./LazyComponent'));

function App() {
  return (
    <SuspenseErrorBoundary>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </SuspenseErrorBoundary>
  );
}

// é”™è¯¯è¾¹ç•ŒåŒ…è£…çš„æ‡’åŠ è½½
const LazyWithErrorBoundary = (props) => (
  <ErrorBoundary
    fallback={({ retry }) => (
      <div>
        <h3>ç»„ä»¶åŠ è½½å¤±è´¥</h3>
        <button onClick={retry}>é‡è¯•</button>
      </div>
    )}
  >
    <React.lazy(() => import(props.component)) />
  </ErrorBoundary>
);

// ä½¿ç”¨
<LazyWithErrorBoundary component="ExpensiveComponent" />
```

</CodeBlock>

### 4.3 è¡¨å•é”™è¯¯å¤„ç†

<CodeBlock>

```jsx
// è¡¨å•é”™è¯¯è¾¹ç•Œ
class FormErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null
    };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Form error:', error);
    // å‘é€è¡¨å•é”™è¯¯åˆ°ç›‘æ§æœåŠ¡
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{ padding: '20px', border: '1px solid #e74c3c' }}>
          <h3>è¡¨å•æäº¤å¤±è´¥</h3>
          <p>è¯·æ£€æŸ¥è¾“å…¥å¹¶é‡è¯•</p>
          <button onClick={this.handleReset}>
            é‡ç½®è¡¨å•
          </button>
        </div>
      );
    }

    return this.props.children;
  }

  handleReset = () => {
    this.setState({
      hasError: false,
      error: null
    });
    this.props.onReset?.();
  };
}

// è¡¨å•ç»„ä»¶
function MyForm({ onSubmit, onReset }) {
  return (
    <FormErrorBoundary onReset={onReset}>
      <form onSubmit={onSubmit}>
        <input name="email" type="email" required />
        <button type="submit">æäº¤</button>
      </form>
    </FormErrorBoundary>
  );
}

// å¸¦æœ‰é”™è¯¯è¾¹ç•Œçš„è¡¨å•åŒ…è£…å™¨
function FormWithErrorHandling({ formConfig }) {
  return (
    <ErrorBoundary
      fallback={({ error }) => (
        <div>
          <h3>è¡¨å•é…ç½®é”™è¯¯</h3>
          <p>è¯·æ£€æŸ¥è¡¨å•é…ç½®</p>
        </div>
      )}
    >
      <FormConfigProvider config={formConfig}>
        <MyForm />
      </FormConfigProvider>
    </ErrorBoundary>
  );
}
```

</CodeBlock>

### 4.4 æ•°æ®è·å–é”™è¯¯å¤„ç†

<CodeBlock>

```jsx
// æ•°æ®è·å–é”™è¯¯è¾¹ç•Œ
class DataFetchErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      data: null
    };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    const { onError } = this.props;

    if (error.name === 'TypeError' && error.message.includes('fetch')) {
      // ç½‘ç»œé”™è¯¯
      console.error('Network error:', error);
    }

    onError?.(error, errorInfo);
  }

  render() {
    const { hasError, error } = this.state;
    const {
      children,
      fallback: Fallback,
      showDataOnError = false
    } = this.props;

    if (hasError) {
      // å°è¯•ä½¿ç”¨ç¼“å­˜æ•°æ®
      if (showDataOnError && this.state.data) {
        return (
          <div>
            <div style={{
              background: '#fff3cd',
              padding: '10px',
              marginBottom: '10px'
            }}>
              <p>âš ï¸ ä½¿ç”¨ç¼“å­˜æ•°æ®ï¼Œå¯èƒ½ä¸æ˜¯æœ€æ–°çš„</p>
            </div>
            {children}
          </div>
        );
      }

      if (Fallback) {
        return <Fallback error={error} retry={this.handleRetry} />;
      }

      return (
        <div>
          <h3>æ•°æ®åŠ è½½å¤±è´¥</h3>
          <p>è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥</p>
          <button onClick={this.handleRetry}>é‡è¯•</button>
        </div>
      );
    }

    return this.props.children;
  }

  handleRetry = () => {
    this.setState({
      hasError: false,
      error: null
    });
    this.props.onRetry?.();
  };
}

// ä¸æ•°æ®è·å–é€»è¾‘ç»“åˆ
class DataComponent extends React.Component {
  state = {
    data: null,
    loading: true,
    error: null
  };

  componentDidMount() {
    this.fetchData();
  }

  fetchData = async () => {
    try {
      this.setState({ loading: true, error: null });
      const data = await fetchData();
      this.setState({ data, loading: false });
    } catch (error) {
      this.setState({ error, loading: false });
    }
  };

  render() {
    const { data, loading, error } = this.state;

    return (
      <DataFetchErrorBoundary
        onError={this.logError}
        onRetry={this.fetchData}
        showDataOnError={true}
      >
        {loading && <div>Loading...</div>}
        {error && <div>Error: {error.message}</div>}
        {data && <div>{data}</div>}
      </DataFetchErrorBoundary>
    );
  }

  logError = (error, errorInfo) => {
    console.error('Data fetch error:', error);
  };
}
```

</CodeBlock>

---

## 5. é”™è¯¯è¾¹ç•Œæœ€ä½³å®è·µ

### 5.1 é”™è¯¯è¾¹ç•Œç²’åº¦

<CodeBlock>

```jsx
// âœ… å¥½çš„å®è·µ - åˆç†åˆ’åˆ†é”™è¯¯è¾¹ç•Œç²’åº¦

// 1. é¡µé¢çº§é”™è¯¯è¾¹ç•Œ
class PageBoundary extends React.Component {
  // æ•è·æ•´ä¸ªé¡µé¢çš„é”™è¯¯
  render() {
    return <ErrorBoundary>{this.props.children}</ErrorBoundary>;
  }
}

// 2. åŠŸèƒ½æ¨¡å—çº§é”™è¯¯è¾¹ç•Œ
class FeatureBoundary extends React.Component {
  // æ•è·ç‰¹å®šåŠŸèƒ½çš„é”™è¯¯
  render() {
    return <ErrorBoundary>{this.props.children}</ErrorBoundary>;
  }
}

// 3. ç»„ä»¶çº§é”™è¯¯è¾¹ç•Œ
class ComponentBoundary extends React.Component {
  // æ•è·å•ä¸ªç»„ä»¶çš„é”™è¯¯
  render() {
    return <ErrorBoundary>{this.props.children}</ErrorBoundary>;
  }
}

// âŒ é¿å…çš„å®è·µ
// 1. åœ¨é”™è¯¯è¾¹ç•Œä¸­æ¸²æŸ“å…¶ä»–å¯èƒ½å‡ºé”™çš„ç»„ä»¶
class BadErrorBoundary extends React.Component {
  render() {
    if (this.state.hasError) {
      return (
        <div>
          <ComplexComponent /> {/* é”™è¯¯è¾¹ç•Œå†…éƒ¨ä¸åº”æœ‰å¤æ‚ç»„ä»¶ */}
        </div>
      );
    }
    return this.props.children;
  }
}

// 2. é”™è¯¯è¾¹ç•Œç²’åº¦å¤ªç»†
function App() {
  return (
    <div>
      <ErrorBoundary><Header /></ErrorBoundary> {/* å¤ªç»† */}
      <ErrorBoundary><Nav /></ErrorBoundary>
      <ErrorBoundary><Main /></ErrorBoundary>
      <ErrorBoundary><Sidebar /></ErrorBoundary>
      <ErrorBoundary><Footer /></ErrorBoundary>
    </div>
  );
}

// âœ… æ¨èçš„å®è·µ
function App() {
  return (
    <ErrorBoundary> {/* é¡µé¢çº§ */}
      <ErrorBoundary> {/* åŠŸèƒ½æ¨¡å—çº§ */}
        <Header />
        <Main />
        <Sidebar />
      </ErrorBoundary>
      <Footer />
    </ErrorBoundary>
  );
}
```

</CodeBlock>

### 5.2 é”™è¯¯è¾¹ç•Œå‘½åå’Œæ–‡æ¡£

<CodeBlock>

```jsx
// âœ… æ¸…æ™°çš„å‘½åå’Œæ–‡æ¡£
/**
 * é¡µé¢é”™è¯¯è¾¹ç•Œ
 * ç”¨äºæ•è·æ•´ä¸ªé¡µé¢çš„é”™è¯¯ï¼Œæ˜¾ç¤ºé™çº§UI
 *
 * @example
 * <PageErrorBoundary fallback={CustomFallback}>
 *   <MyPage />
 * </PageErrorBoundary>
 */
class PageErrorBoundary extends React.Component {
  // å®ç°
}

/**
 * ç»„ä»¶é”™è¯¯è¾¹ç•Œ
 * ç”¨äºå•ä¸ªç»„ä»¶çš„é”™è¯¯å¤„ç†
 */
class ComponentErrorBoundary extends React.Component {
  // å®ç°
}

// ä½¿ç”¨JSDocè®°å½•Props
/**
 * @param {Object} props
 * @param {React.Component} props.children - å­ç»„ä»¶
 * @param {Function} [props.fallback] - é”™è¯¯é™çº§ç»„ä»¶
 * @param {Function} [props.onError] - é”™è¯¯å›è°ƒ
 * @param {number} [props.maxRetries=3] - æœ€å¤§é‡è¯•æ¬¡æ•°
 */
class ErrorBoundary extends React.Component {
  // å®ç°
}

// âœ… æä¾›ä½¿ç”¨ç¤ºä¾‹
/**
 * ä½¿ç”¨ç¤ºä¾‹ï¼š
 *
 * ```jsx
 * // 1. ä½¿ç”¨é»˜è®¤é™çº§UI
 * <ErrorBoundary>
 *   <MyComponent />
 * </ErrorBoundary>
 *
 * // 2. ä½¿ç”¨è‡ªå®šä¹‰é™çº§UI
 * <ErrorBoundary
 *   fallback={({ error, retry }) => (
 *     <div>å‡ºé”™äº†: {error.message}</div>
 *   )}
 * >
 *   <MyComponent />
 * </ErrorBoundary>
 *
 * // 3. å¸¦é”™è¯¯ä¸ŠæŠ¥
 * <ErrorBoundary
 *   onError={(error, errorInfo) => {
 *     logErrorToService(error);
 *   }}
 * >
 *   <MyComponent />
 * </ErrorBoundary>
 * ```
 */
class ErrorBoundary extends React.Component {
  // å®ç°
}
```

</CodeBlock>

### 5.3 é”™è¯¯ç›‘æ§é›†æˆ

<CodeBlock>

```jsx
// é”™è¯¯ç›‘æ§æœåŠ¡
class ErrorMonitoringService {
  static report(error, errorInfo) {
    // å‘é€åˆ°ç›‘æ§æœåŠ¡
    console.log('Reporting error:', { error, errorInfo });
  }

  static captureException(error, context = {}) {
    this.report(error, { context });
  }
}

// é”™è¯¯è¾¹ç•Œä¸ç›‘æ§æœåŠ¡é›†æˆ
class MonitoredErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    // é”™è¯¯åˆ†ç±»
    const errorType = this.classifyError(error);

    // æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯
    const context = {
      ...this.props.context,
      userAgent: navigator.userAgent,
      url: window.location.href,
      timestamp: new Date().toISOString()
    };

    // ä¸ŠæŠ¥é”™è¯¯
    this.reportError(error, errorInfo, context);

    // è°ƒç”¨ç”¨æˆ·å›è°ƒ
    this.props.onError?.(error, errorInfo);
  }

  classifyError(error) {
    if (error.name === 'ChunkLoadError') {
      return 'lazy-loading';
    }
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
      return 'network';
    }
    if (error.message.includes('render')) {
      return 'rendering';
    }
    return 'unknown';
  }

  reportError(error, errorInfo, context) {
    const errorReport = {
      name: error.name,
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      context
    };

    ErrorMonitoringService.captureException(error, errorReport);
  }

  render() {
    if (this.state.hasError) {
      const { fallback } = this.props;
      return fallback || <DefaultErrorFallback />;
    }
    return this.props.children;
  }
}

// ä½¿ç”¨
<MonitoredErrorBoundary
  context={{
    userId: '123',
    feature: 'user-dashboard'
  }}
  onError={(error, errorInfo) => {
    // æœ¬åœ°å¤„ç†
    console.error('Local error handling');
  }}
>
  <MyComponent />
</MonitoredErrorBoundary>
```

</CodeBlock>

### 5.4 é”™è¯¯è¾¹ç•Œæµ‹è¯•

<CodeBlock>

```jsx
// é”™è¯¯è¾¹ç•Œæµ‹è¯•
import { render, screen, fireEvent } from '@testing-library/react';

// æµ‹è¯•é”™è¯¯è¾¹ç•Œæ˜¯å¦æ­£ç¡®æ¸²æŸ“é™çº§UI
test('ErrorBoundary renders fallback when child throws', () => {
  const ThrowError = () => {
    throw new Error('Test error');
  };

  render(
    <ErrorBoundary>
      <ThrowError />
    </ErrorBoundary>
  );

  expect(screen.getByText(/something went wrong/i)).toBeInTheDocument();
});

// æµ‹è¯•é”™è¯¯è¾¹ç•Œå¯ä»¥æ¢å¤
test('ErrorBoundary can recover after error', () => {
  let shouldThrow = true;

  const ConditionalComponent = () => {
    if (shouldThrow) {
      throw new Error('Test error');
    }
    return <div>No error</div>;
  };

  const { rerender } = render(
    <ErrorBoundary>
      <ConditionalComponent />
    </ErrorBoundary>
  );

  expect(screen.getByText(/something went wrong/i)).toBeInTheDocument();

  // é‡ç½®é”™è¯¯çŠ¶æ€
  shouldThrow = false;
  rerender(
    <ErrorBoundary>
      <ConditionalComponent />
    </ErrorBoundary>
  );

  expect(screen.getByText(/no error/i)).toBeInTheDocument();
});

// æµ‹è¯•é”™è¯¯ä¸ŠæŠ¥
test('ErrorBoundary calls onError when error occurs', () => {
  const onError = jest.fn();

  const ThrowError = () => {
    throw new Error('Test error');
  };

  render(
    <ErrorBoundary onError={onError}>
      <ThrowError />
    </ErrorBoundary>
  );

  expect(onError).toHaveBeenCalledWith(
    expect.any(Error),
    expect.any(Object)
  );
});

// æµ‹è¯•è‡ªå®šä¹‰é™çº§UI
test('ErrorBoundary renders custom fallback', () => {
  const CustomFallback = ({ error }) => (
    <div>Custom error: {error.message}</div>
  );

  const ThrowError = () => {
    throw new Error('Test error');
  };

  render(
    <ErrorBoundary fallback={CustomFallback}>
      <ThrowError />
    </ErrorBoundary>
  );

  expect(screen.getByText(/custom error: test error/i)).toBeInTheDocument();
});
```

</CodeBlock>

---

## 6. é”™è¯¯è¾¹ç•Œçš„å±€é™æ€§å’Œæ³¨æ„äº‹é¡¹

### 6.1 é”™è¯¯è¾¹ç•Œæ— æ³•æ•è·çš„é”™è¯¯

<CodeBlock>

```jsx
// âŒ é”™è¯¯è¾¹ç•Œæ— æ³•æ•è·ä»¥ä¸‹é”™è¯¯ï¼š

// 1. äº‹ä»¶å¤„ç†å™¨ä¸­çš„é”™è¯¯
function MyComponent() {
  const handleClick = () => {
    throw new Error('Event handler error'); // é”™è¯¯è¾¹ç•Œæ— æ³•æ•è·
  };

  return <button onClick={handleClick}>Click me</button>;
}

// æ­£ç¡®å¤„ç†æ–¹å¼ï¼šä½¿ç”¨try-catch
function MyComponent() {
  const handleClick = () => {
    try {
      // å¯èƒ½æœ‰é”™è¯¯çš„ä»£ç 
      throw new Error('Event handler error');
    } catch (error) {
      console.error(error);
      // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„é”™è¯¯
    }
  };

  return <button onClick={handleClick}>Click me</button>;
}

// 2. å¼‚æ­¥ä»£ç ä¸­çš„é”™è¯¯
function MyComponent() {
  useEffect(() => {
    fetch('/api/data')
      .then(data => {
        throw new Error('Async error'); // é”™è¯¯è¾¹ç•Œæ— æ³•æ•è·
      });
  }, []);

  return <div>My Component</div>;
}

// æ­£ç¡®å¤„ç†æ–¹å¼ï¼šæ·»åŠ .catch()
function MyComponent() {
  useEffect(() => {
    fetch('/api/data')
      .then(data => {
        // å¤„ç†æ•°æ®
      })
      .catch(error => {
        console.error(error);
        // è®¾ç½®é”™è¯¯çŠ¶æ€
      });
  }, []);

  return <div>My Component</div>;
}

// 3. æœåŠ¡ç«¯æ¸²æŸ“(SSR)é”™è¯¯
// é”™è¯¯è¾¹ç•Œåœ¨æœåŠ¡ç«¯ä¸å·¥ä½œ

// 4. é”™è¯¯è¾¹ç•Œè‡ªèº«çš„é”™è¯¯
class BadErrorBoundary extends React.Component {
  render() {
    if (this.state.hasError) {
      this.props.fallback(); // å¦‚æœfallbackæ˜¯å‡½æ•°ï¼Œé”™è¯¯è¾¹ç•Œä¼šå‡ºé”™
      return <div>Error</div>;
    }
    return this.props.children;
  }
}

// âœ… æ­£ç¡®å¤„ç†
class GoodErrorBoundary extends React.Component {
  render() {
    if (this.state.hasError) {
      if (typeof this.props.fallback === 'function') {
        return this.props.fallback({ error: this.state.error });
      }
      return <div>Error</div>;
    }
    return this.props.children;
  }
}
```

</CodeBlock>

### 6.2 æ€§èƒ½æ³¨æ„äº‹é¡¹

<CodeBlock>

```jsx
// âœ… æ€§èƒ½ä¼˜åŒ–

// 1. é¿å…åœ¨é”™è¯¯è¾¹ç•Œä¸­åˆ›å»ºå¯¹è±¡
class OptimizedErrorBoundary extends React.Component {
  // é¿å…æ¯æ¬¡æ¸²æŸ“éƒ½åˆ›å»ºæ–°å¯¹è±¡
  defaultFallback = () => (
    <div>å‡ºé”™äº†</div>
  );

  render() {
    if (this.state.hasError) {
      // ä½¿ç”¨å®ä¾‹å±æ€§è€Œä¸æ˜¯åœ¨renderä¸­åˆ›å»º
      return this.props.fallback || this.defaultFallback;
    }
    return this.props.children;
  }
}

// 2. æ­£ç¡®ä½¿ç”¨React.memo
const ComponentWithErrorBoundary = React.memo(({ data }) => {
  return <div>{data}</div>;
});

<ErrorBoundary>
  <ComponentWithErrorBoundary />
</ErrorBoundary>

// 3. é¿å…æ·±å±‚åµŒå¥—
// âŒ ä¸å¥½
<ErrorBoundary>
  <ErrorBoundary>
    <ErrorBoundary>
      <ErrorBoundary>
        <MyComponent />
      </ErrorBoundary>
    </ErrorBoundary>
  </ErrorBoundary>
</ErrorBoundary>

// âœ… å¥½
<ErrorBoundary>
  <MyComponent />
</ErrorBoundary>

// 4. æ¡ä»¶æ¸²æŸ“é”™è¯¯è¾¹ç•Œ
function App({ enableErrorBoundary }) {
  return (
    <div>
      {enableErrorBoundary && (
        <ErrorBoundary>
          <MyComponent />
        </ErrorBoundary>
      )}
    </div>
  );
}
```

</CodeBlock>

### 6.3 è°ƒè¯•å’Œå¼€å‘ä½“éªŒ

<CodeBlock>

```jsx
// å¼€å‘ç¯å¢ƒå¢å¼ºé”™è¯¯è¾¹ç•Œ
class DevelopmentErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    // å¼€å‘ç¯å¢ƒä¸‹è¯¦ç»†é”™è¯¯ä¿¡æ¯
    if (process.env.NODE_ENV === 'development') {
      console.group('ğŸš¨ ErrorBoundary Caught an Error');
      console.error('Error:', error);
      console.error('Error Info:', errorInfo);
      console.error('Component Stack:', errorInfo.componentStack);
      console.groupEnd();
    }

    // ç”Ÿäº§ç¯å¢ƒåªè®°å½•å¿…è¦ä¿¡æ¯
    this.reportError(error, errorInfo);
  }

  reportError(error, errorInfo) {
    if (process.env.NODE_ENV === 'production') {
      // ç”Ÿäº§ç¯å¢ƒé”™è¯¯ä¸ŠæŠ¥
      console.error('Error reported:', error.message);
    }
  }

  render() {
    if (this.state.hasError) {
      // å¼€å‘ç¯å¢ƒæ˜¾ç¤ºè¯¦ç»†é”™è¯¯
      if (process.env.NODE_ENV === 'development') {
        return (
          <div style={{ padding: '20px', background: '#ffebee' }}>
            <h2>Development Mode - Error Details</h2>
            <details>
              <summary>Error Stack</summary>
              <pre>{this.state.error?.stack}</pre>
            </details>
            <details>
              <summary>Component Stack</summary>
              <pre>{this.state.errorInfo?.componentStack}</pre>
            </details>
          </div>
        );
      }

      // ç”Ÿäº§ç¯å¢ƒæ˜¾ç¤ºç”¨æˆ·å‹å¥½é”™è¯¯
      return (
        <div>
          <h2>å‡ºé”™äº†</h2>
          <p>è¯·ç¨åé‡è¯•</p>
        </div>
      );
    }

    return this.props.children;
  }
}

// React DevToolsæ”¯æŒ
class DevToolsErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    // è®¾ç½®ç»„ä»¶åç§°ä¾¿äºè°ƒè¯•
    this.componentName = this.props.name || 'UnknownComponent';

    console.error(
      `Error in component: ${this.componentName}`,
      error,
      errorInfo
    );
  }

  render() {
    if (this.state.hasError) {
      return <div>Error in {this.componentName}</div>;
    }
    return this.props.children;
  }
}
```

</CodeBlock>

---

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 7.1 å®Œæ•´é”™è¯¯è¾¹ç•Œç³»ç»Ÿ

<CodeBlock>

```jsx
// é”™è¯¯è¾¹ç•Œç³»ç»Ÿ
const ErrorBoundaryContext = React.createContext();

function ErrorBoundaryProvider({ children, onError }) {
  const [errors, setErrors] = React.useState([]);

  const handleError = React.useCallback((error, errorInfo) => {
    const errorEntry = {
      id: Date.now(),
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      timestamp: new Date().toISOString()
    };

    setErrors(prev => [errorEntry, ...prev]);

    // è§¦å‘é”™è¯¯å›è°ƒ
    onError?.(error, errorInfo);
  }, [onError]);

  return (
    <ErrorBoundaryContext.Provider value={{ errors, handleError }}>
      {children}
    </ErrorBoundaryContext.Provider>
  );
}

// å…¨å±€é”™è¯¯è¾¹ç•Œ
class GlobalErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    this.props.onError?.(error, errorInfo);
    console.error('Global error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          flexDirection: 'column'
        }}>
          <h1>ğŸ˜” æŠ±æ­‰ï¼Œé¡µé¢å‡ºç°äº†é—®é¢˜</h1>
          <p>æˆ‘ä»¬çš„å·¥ç¨‹å¸ˆå·²ç»æ”¶åˆ°é”™è¯¯æŠ¥å‘Š</p>
          <button onClick={() => window.location.reload()}>
            åˆ·æ–°é¡µé¢
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// é¡µé¢é”™è¯¯è¾¹ç•Œ
class PageErrorBoundary extends React.Component {
  render() {
    return (
      <ErrorBoundary
        fallback={({ error, retry }) => (
          <div style={{ padding: '40px' }}>
            <h2>é¡µé¢åŠ è½½å¤±è´¥</h2>
            <p>æ­¤é¡µé¢é‡åˆ°äº†é—®é¢˜</p>
            <div>
              <button onClick={retry}>é‡è¯•</button>
              <button onClick={() => window.location.href = '/'}>
                è¿”å›é¦–é¡µ
              </button>
            </div>
            {process.env.NODE_ENV === 'development' && (
              <details>
                <summary>é”™è¯¯è¯¦æƒ…</summary>
                <pre>{error?.stack}</pre>
              </details>
            )}
          </div>
        )}
      >
        {this.props.children}
      </ErrorBoundary>
    );
  }
}

// ä½¿ç”¨é”™è¯¯è¾¹ç•Œç³»ç»Ÿ
function App() {
  return (
    <ErrorBoundaryProvider
      onError={(error, errorInfo) => {
        // å‘é€åˆ°ç›‘æ§æœåŠ¡
        console.log('Error reported:', error);
      }}
    >
      <GlobalErrorBoundary>
        <Router>
          <Routes>
            <Route
              path="/"
              element={
                <PageErrorBoundary>
                  <HomePage />
                </PageErrorBoundary>
              }
            />
            <Route
              path="/dashboard"
              element={
                <PageErrorBoundary>
                  <Dashboard />
                </PageErrorBoundary>
              }
            />
          </Routes>
        </Router>
      </GlobalErrorBoundary>
    </ErrorBoundaryProvider>
  );
}
```

</CodeBlock>

### 7.2 é”™è¯¯è¾¹ç•ŒHook

<CodeBlock>

```jsx
// é”™è¯¯è¾¹ç•ŒHookï¼ˆä»…é€‚ç”¨äºç±»ç»„ä»¶åŒ…è£…ï¼‰
function useErrorHandler() {
  return {
    // æ‰‹åŠ¨æ•è·é”™è¯¯
    captureError: (error, context = {}) => {
      console.error('Captured error:', { error, context });
      // å¯ä»¥å‘é€åˆ°é”™è¯¯ç›‘æ§
    },
    // åˆ›å»ºé”™è¯¯å›è°ƒ
    createErrorHandler: (errorCallback) => (error, errorInfo) => {
      console.error('Component error:', error);
      errorCallback?.(error, errorInfo);
    }
  };
}

// åœ¨ç±»ç»„ä»¶ä¸­ä½¿ç”¨
class MyComponent extends React.Component {
  componentDidMount() {
    const errorHandler = useErrorHandler();

    // æ‰‹åŠ¨é”™è¯¯å¤„ç†
    try {
      // å¯èƒ½å‡ºé”™çš„ä»£ç 
    } catch (error) {
      errorHandler.captureError(error, {
        component: 'MyComponent',
        action: 'componentDidMount'
      });
    }
  }

  render() {
    return <div>My Component</div>;
  }
}

// é”™è¯¯çŠ¶æ€Hookï¼ˆç”¨äºå‡½æ•°ç»„ä»¶ï¼‰
function useErrorState() {
  const [error, setError] = React.useState(null);

  const resetError = React.useCallback(() => {
    setError(null);
  }, []);

  const throwError = React.useCallback((error) => {
    setError(error);
  }, []);

  React.useEffect(() => {
    if (error) {
      throw error;
    }
  }, [error]);

  return { error, resetError, throwError };
}

// ä½¿ç”¨
function MyFunctionalComponent() {
  const { error, resetError } = useErrorState();

  if (error) {
    return (
      <div>
        <p>å‡ºé”™äº†: {error.message}</p>
        <button onClick={resetError}>é‡è¯•</button>
      </div>
    );
  }

  return <div>Normal state</div>;
}
```

</CodeBlock>

### 7.3 é”™è¯¯è¾¹ç•Œä¸æ—¥å¿—ç³»ç»Ÿ

<CodeBlock>

```jsx
// æ—¥å¿—ç³»ç»Ÿ
class Logger {
  static logs = [];

  static log(level, message, data) {
    const logEntry = {
      id: Date.now(),
      level,
      message,
      data,
      timestamp: new Date().toISOString()
    };

    this.logs.unshift(logEntry);

    // ä¿æŒæ—¥å¿—æ•°é‡é™åˆ¶
    if (this.logs.length > 100) {
      this.logs = this.logs.slice(0, 100);
    }

    return logEntry;
  }

  static error(message, error, context) {
    return this.log('error', message, { error, context });
  }

  static getLogs() {
    return this.logs;
  }
}

// å¸¦æ—¥å¿—çš„é”™è¯¯è¾¹ç•Œ
class LoggingErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    const { context, onError } = this.props;

    // è®°å½•é”™è¯¯
    Logger.error('Component error', error, {
      context,
      componentStack: errorInfo.componentStack,
      errorBoundary: this.constructor.name
    });

    // è§¦å‘å›è°ƒ
    onError?.(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || <DefaultErrorFallback />;
    }
    return this.props.children;
  }
}

// æ—¥å¿—æŸ¥çœ‹å™¨ç»„ä»¶
function LogViewer() {
  const [logs, setLogs] = React.useState(Logger.getLogs());

  React.useEffect(() => {
    const interval = setInterval(() => {
      setLogs(Logger.getLogs());
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return (
    <div style={{
      position: 'fixed',
      bottom: '20px',
      right: '20px',
      background: 'white',
      border: '1px solid #ccc',
      padding: '10px',
      maxHeight: '300px',
      overflow: 'auto'
    }}>
      <h4>Error Logs</h4>
      {logs.map(log => (
        <div key={log.id} style={{
          borderBottom: '1px solid #eee',
          padding: '5px 0'
        }}>
          <div style={{ fontSize: '12px', color: '#666' }}>
            {log.timestamp}
          </div>
          <div style={{
            color: log.level === 'error' ? 'red' : 'black',
            fontSize: '12px'
          }}>
            {log.message}
          </div>
        </div>
      ))}
    </div>
  );
}

// ä½¿ç”¨
<LoggingErrorBoundary
  context={{ userId: '123', page: 'dashboard' }}
  onError={(error, errorInfo) => {
    // å¯ä»¥æ·»åŠ é¢å¤–å¤„ç†
  }}
>
  <MyComponent />
</LoggingErrorBoundary>

<LogViewer />
```

</CodeBlock>

### 7.4 é”™è¯¯è¾¹ç•Œé…ç½®ç³»ç»Ÿ

<CodeBlock>

```jsx
// é”™è¯¯è¾¹ç•Œé…ç½®
const ERROR_BOUNDARY_CONFIG = {
  // å…¨å±€é…ç½®
  global: {
    enableErrorReporting: true,
    enableAutoRetry: true,
    maxRetries: 3
  },

  // æŒ‰è·¯ç”±é…ç½®
  routes: {
    '/': {
      enableErrorBoundary: true,
      showDetails: false
    },
    '/dashboard': {
      enableErrorBoundary: true,
      showDetails: true,
      customFallback: DashboardErrorFallback
    }
  },

  // æŒ‰ç»„ä»¶é…ç½®
  components: {
    'Header': {
      enableErrorBoundary: false
    },
    'Footer': {
      enableErrorBoundary: false
    },
    'ExpensiveComponent': {
      enableErrorBoundary: true,
      maxRetries: 5,
      autoRetry: true
    }
  }
};

// é”™è¯¯è¾¹ç•Œå·¥å‚
function createErrorBoundary(config = {}) {
  return class extends React.Component {
    static getDerivedStateFromError(error) {
      return { hasError: true, error };
    }

    componentDidCatch(error, errorInfo) {
      const { onError, enableErrorReporting = true } = this.props;

      if (enableErrorReporting) {
        console.error('ErrorBoundary:', error, errorInfo);
      }

      onError?.(error, errorInfo);
    }

    render() {
      const {
        fallback,
        children,
        showDetails = false
      } = this.props;

      if (this.state.hasError) {
        if (fallback) {
          return <>{fallback}</>;
        }

        return (
          <div>
            <h2>å‡ºé”™äº†</h2>
            {showDetails && (
              <pre>{this.state.error?.stack}</pre>
            )}
          </div>
        );
      }

      return children;
    }
  };
}

// é…ç½®æ„ŸçŸ¥çš„é”™è¯¯è¾¹ç•Œç»„ä»¶
function ConfigurableErrorBoundary({
  componentName,
  routePath,
  children
}) {
  const config = React.useMemo(() => {
    const routeConfig = ERROR_BOUNDARY_CONFIG.routes[routePath] || {};
    const componentConfig = ERROR_BOUNDARY_CONFIG.components[componentName] || {};

    return {
      ...ERROR_BOUNDARY_CONFIG.global,
      ...routeConfig,
      ...componentConfig
    };
  }, [componentName, routePath]);

  if (!config.enableErrorBoundary) {
    return children;
  }

  const ErrorBoundary = createErrorBoundary(config);

  return (
    <ErrorBoundary
      enableErrorReporting={config.enableErrorReporting}
      fallback={config.customFallback}
      maxRetries={config.maxRetries}
    >
      {children}
    </ErrorBoundary>
  );
}

// ä½¿ç”¨é…ç½®åŒ–é”™è¯¯è¾¹ç•Œ
function App() {
  return (
    <Router>
      <ConfigurableErrorBoundary
        componentName="App"
        routePath="/"
      >
        <Routes>
          <Route path="/" element={
            <ConfigurableErrorBoundary
              componentName="HomePage"
              routePath="/"
            >
              <HomePage />
            </ConfigurableErrorBoundary>
          } />
          <Route path="/dashboard" element={
            <ConfigurableErrorBoundary
              componentName="Dashboard"
              routePath="/dashboard"
            >
              <Dashboard />
            </ConfigurableErrorBoundary>
          } />
        </Routes>
      </ConfigurableErrorBoundary>
    </Router>
  );
}
```

</CodeBlock>

---

## 8. å®è·µç»ƒä¹ 

### ç»ƒä¹ 1ï¼šåˆ›å»ºåŸºç¡€é”™è¯¯è¾¹ç•Œç»„ä»¶

<Expandable title="ç‚¹å‡»æŸ¥çœ‹è¦æ±‚">

**åŠŸèƒ½è¦æ±‚**ï¼š
- å®ç°åŸºç¡€é”™è¯¯è¾¹ç•Œç±»ç»„ä»¶
- ä½¿ç”¨getDerivedStateFromErrorå’ŒcomponentDidCatch
- æ”¯æŒè‡ªå®šä¹‰é™çº§UI
- é”™è¯¯æ¢å¤åŠŸèƒ½

**å®ç°è¦æ±‚**ï¼š
```javascript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    // æ›´æ–°stateæ˜¾ç¤ºé™çº§UI
  }

  componentDidCatch(error, errorInfo) {
    // è®°å½•é”™è¯¯
  }

  render() {
    // è¿”å›é™çº§UIæˆ–æ­£å¸¸å­ç»„ä»¶
  }
}
```

**æç¤º**ï¼š
- æ­£ç¡®è®¾ç½®hasErrorçŠ¶æ€
- åœ¨componentDidCatchä¸­è®°å½•é”™è¯¯
- æä¾›é‡è¯•åŠŸèƒ½
- ä½¿ç”¨React.Component

</Expandable>

### ç»ƒä¹ 2ï¼šåˆ›å»ºå¸¦é”™è¯¯ä¸ŠæŠ¥çš„é”™è¯¯è¾¹ç•Œ

<Expandable title="ç‚¹å‡»æŸ¥çœ‹è¦æ±‚">

**åŠŸèƒ½è¦æ±‚**ï¼š
- é”™è¯¯è¾¹ç•Œé›†æˆé”™è¯¯ç›‘æ§æœåŠ¡
- å‘é€é”™è¯¯è¯¦æƒ…åˆ°æœåŠ¡å™¨
- ç”Ÿæˆé”™è¯¯IDç”¨äºè¿½è¸ª
- æ”¯æŒç¦»çº¿é”™è¯¯ç¼“å­˜

**å®ç°è¦æ±‚**ï¼š
```javascript
class ErrorBoundaryWithReporting extends React.Component {
  reportError(error, errorInfo) {
    // å‘é€åˆ°é”™è¯¯ç›‘æ§æœåŠ¡
    // é”™è¯¯åº”åŒ…å«: message, stack, componentStack, timestamp, userAgent
  }

  componentDidCatch(error, errorInfo) {
    // è®°å½•å’Œä¸ŠæŠ¥
  }
}
```

**æç¤º**ï¼š
- ä½¿ç”¨fetchå‘é€POSTè¯·æ±‚
- ç”Ÿæˆå”¯ä¸€é”™è¯¯ID
- å¤„ç†ç½‘ç»œé”™è¯¯
- ç¦»çº¿æ—¶ç¼“å­˜é”™è¯¯

</Expandable>

### ç»ƒä¹ 3ï¼šåˆ›å»ºå¤šçº§é”™è¯¯è¾¹ç•Œç³»ç»Ÿ

<Expandable title="ç‚¹å‡»æŸ¥çœ‹è¦æ±‚">

**åŠŸèƒ½è¦æ±‚**ï¼š
- å®ç°é¡µé¢çº§ã€ç»„ä»¶çº§ã€åŒºåŸŸçº§é”™è¯¯è¾¹ç•Œ
- ä¸åŒçº§åˆ«ä½¿ç”¨ä¸åŒé™çº§UI
- æ”¯æŒé”™è¯¯è¾¹ç•ŒåµŒå¥—
- é”™è¯¯éš”ç¦»

**å®ç°è¦æ±‚**ï¼š
```javascript
// é¡µé¢çº§
class PageErrorBoundary { ... }

// ç»„ä»¶çº§
class ComponentErrorBoundary { ... }

// åŒºåŸŸçº§
class SectionErrorBoundary { ... }

// ä½¿ç”¨ç¤ºä¾‹
<PageErrorBoundary>
  <ComponentErrorBoundary>
    <SectionErrorBoundary>
      <MyComponent />
    </SectionErrorBoundary>
  </ComponentErrorBoundary>
</PageErrorBoundary>
```

**æç¤º**ï¼š
- åˆç†åˆ’åˆ†é”™è¯¯è¾¹ç•Œç²’åº¦
- é¿å…è¿‡åº¦åµŒå¥—
- ä¸åŒçº§åˆ«ä¸åŒç­–ç•¥
- é”™è¯¯ä¸ä¼šå‘ä¸Šä¼ æ’­

</Expandable>

### ç»ƒä¹ 4ï¼šåˆ›å»ºé”™è¯¯æ¢å¤æœºåˆ¶

<Expandable title="ç‚¹å‡»æŸ¥çœ‹è¦æ±‚">

**åŠŸèƒ½è¦æ±‚**ï¼š
- é”™è¯¯è¾¹ç•Œæ”¯æŒè‡ªåŠ¨é‡è¯•
- æ‰‹åŠ¨é‡è¯•åŠŸèƒ½
- æœ€å¤§é‡è¯•æ¬¡æ•°é™åˆ¶
- é‡è¯•çŠ¶æ€æ˜¾ç¤º

**å®ç°è¦æ±‚**ï¼š
```javascript
class RecoverableErrorBoundary extends React.Component {
  maxRetries = 3;

  componentDidCatch(error, errorInfo) {
    // è‡ªåŠ¨é‡è¯•é€»è¾‘
  }

  handleRetry = () => {
    // é‡ç½®é”™è¯¯çŠ¶æ€
  }

  handleReset = () => {
    // å®Œå…¨é‡ç½®
  }
}
```

**æç¤º**ï¼š
- ä½¿ç”¨setTimeoutå®ç°å»¶è¿Ÿé‡è¯•
- é€’å¢å»¶è¿Ÿæ—¶é—´
- è¿½è¸ªé‡è¯•æ¬¡æ•°
- æ˜¾ç¤ºé‡è¯•çŠ¶æ€

</Expandable>

---

## 9. æœ¬ç« å°ç»“

### å…³é”®è¦ç‚¹

<Checklist>

- âœ… é”™è¯¯è¾¹ç•Œæ˜¯Reactç±»ç»„ä»¶ç‰¹æœ‰çš„æ¨¡å¼
- âœ… ä½¿ç”¨getDerivedStateFromErroræ›´æ–°çŠ¶æ€
- âœ… ä½¿ç”¨componentDidCatchè®°å½•é”™è¯¯
- âœ… é”™è¯¯è¾¹ç•Œæ— æ³•æ•è·äº‹ä»¶å¤„ç†å™¨é”™è¯¯
- âœ… é”™è¯¯è¾¹ç•Œæ— æ³•æ•è·å¼‚æ­¥ä»£ç é”™è¯¯
- âœ… åˆç†åˆ’åˆ†é”™è¯¯è¾¹ç•Œç²’åº¦
- âœ… æä¾›ç”¨æˆ·å‹å¥½çš„é™çº§UI
- âœ… é›†æˆé”™è¯¯ç›‘æ§å’Œä¸ŠæŠ¥
- âœ… æ”¯æŒé”™è¯¯æ¢å¤å’Œé‡è¯•
- âœ… åœ¨å¼€å‘å’Œç”Ÿäº§ç¯å¢ƒä½¿ç”¨ä¸åŒç­–ç•¥

</Checklist>

### é”™è¯¯è¾¹ç•Œæœ€ä½³å®è·µ

<BestPractices>

1. **åˆç†ç²’åº¦** - é¡µé¢çº§æˆ–åŠŸèƒ½æ¨¡å—çº§ï¼Œä¸è¦è¿‡ç»†
2. **ç”¨æˆ·å‹å¥½** - æ˜¾ç¤ºæ¸…æ™°çš„é”™è¯¯ä¿¡æ¯ï¼Œé¿å…æŠ€æœ¯ç»†èŠ‚
3. **é”™è¯¯ä¸ŠæŠ¥** - é›†æˆé”™è¯¯ç›‘æ§æœåŠ¡ï¼Œè¿½è¸ªç”Ÿäº§ç¯å¢ƒé”™è¯¯
4. **æ€§èƒ½ä¼˜åŒ–** - é¿å…åœ¨é”™è¯¯è¾¹ç•Œä¸­åˆ›å»ºæ–°å¯¹è±¡
5. **å¼€å‘ä½“éªŒ** - å¼€å‘ç¯å¢ƒæ˜¾ç¤ºè¯¦ç»†é”™è¯¯ï¼Œç”Ÿäº§ç¯å¢ƒéšè—
6. **æµ‹è¯•è¦†ç›–** - æµ‹è¯•é”™è¯¯è¾¹ç•Œåœ¨å„ç§åœºæ™¯ä¸‹çš„è¡Œä¸º
7. **æ–‡æ¡£å®Œæ•´** - è®°å½•é”™è¯¯è¾¹ç•Œçš„ä½¿ç”¨æ–¹æ³•å’Œé…ç½®
8. **æ¢å¤æœºåˆ¶** - æä¾›é‡è¯•æˆ–æ¢å¤é€‰é¡¹

</BestPractices>

### é”™è¯¯è¾¹ç•Œé€‚ç”¨åœºæ™¯

<BestPractices>

**é€‚åˆä½¿ç”¨**ï¼š
- é¡µé¢çº§é”™è¯¯éš”ç¦»
- å¤æ‚ç»„ä»¶å®¹é”™
- ç¬¬ä¸‰æ–¹ç»„ä»¶åŒ…è£…
- æ•°æ®è·å–é”™è¯¯å¤„ç†
- æ‡’åŠ è½½ç»„ä»¶é”™è¯¯

**ä¸é€‚åˆä½¿ç”¨**ï¼š
- äº‹ä»¶å¤„ç†å™¨
- å¼‚æ­¥ä»£ç 
- æœåŠ¡ç«¯æ¸²æŸ“
- ç®€å•ç»„ä»¶

</BestPractices>

### ä¸‹ä¸€æ­¥å­¦ä¹ 

ç°åœ¨ä½ å·²ç»æŒæ¡äº†é”™è¯¯è¾¹ç•Œï¼Œæ¥ä¸‹æ¥å¯ä»¥å­¦ä¹ ï¼š

1. **[Childrenæ¨¡å¼](../advanced/children-patterns)** - æ·±å…¥React children
2. **[Props Gettersæ¨¡å¼](../advanced/props-getters)** - çµæ´»çš„Propsä¼ é€’
3. **[å—æ§ä¸éå—æ§](../advanced/controlled-uncontrolled)** - è¡¨å•ç»„ä»¶æ¨¡å¼
4. **[ç»„åˆ vs ç»§æ‰¿](../advanced/composition-vs-inheritance)** - Reactè®¾è®¡å“²å­¦

---

## 10. å»¶ä¼¸é˜…è¯»

### å®˜æ–¹èµ„æº

- [é”™è¯¯è¾¹ç•Œ](https://react.dev/reference/react) - Reactå®˜æ–¹æ–‡æ¡£
- [getDerivedStateFromError](https://react.dev/reference/react) - ç”Ÿå‘½å‘¨æœŸæ–¹æ³•
- [ç»„ä»¶é”™è¯¯å¤„ç†](https://react.dev/reference/react) - é”™è¯¯å¤„ç†æŒ‡å—

### æ¨èé˜…è¯»

- [é”™è¯¯è¾¹ç•Œæœ€ä½³å®è·µ](https://kentcdodds.com/blog/) - é”™è¯¯å¤„ç†æ¨¡å¼
- [Reacté”™è¯¯ç›‘æ§](https://blog.logrocket.com/) - é”™è¯¯ç›‘æ§æŒ‡å—
- [é”™è¯¯è¾¹ç•Œvsé”™è¯¯å¤„ç†](https://reactpatterns.com/) - æ¨¡å¼å¯¹æ¯”

### ç›¸å…³è¯é¢˜

- [é”™è¯¯å¤„ç†](https://react.dev/learn/thinking-in-react) - Reacté”™è¯¯æ€ç»´
- [è°ƒè¯•React](https://react.dev/learn/) - è°ƒè¯•æŠ€å·§
- [é”™è¯¯æ¢å¤](https://react.dev/reference/react) - é”™è¯¯æ¢å¤æ¨¡å¼

---

[â† ä¸Šä¸€ç« ï¼šHooksæ¨¡å¼](../advanced/hooks-patterns) | [ä¸‹ä¸€ç« ï¼šChildrenæ¨¡å¼ â†’](../advanced/children-patterns)
