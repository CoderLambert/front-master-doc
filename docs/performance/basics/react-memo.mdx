# React.memoåŸºç¡€ - ç»„ä»¶æ€§èƒ½ä¼˜åŒ–åˆ©å™¨

import { Tabs, TabItem } from '@docusaurus/theme-common';

React.memoæ˜¯React 16.6å¼•å…¥çš„é«˜é˜¶ç»„ä»¶ï¼Œç”¨äºä¼˜åŒ–ç»„ä»¶æ¸²æŸ“æ€§èƒ½ã€‚å®ƒé€šè¿‡è®°å¿†åŒ–ï¼ˆmemoizationï¼‰æŠ€æœ¯é¿å…ä¸å¿…è¦çš„é‡æ–°æ¸²æŸ“ï¼Œæ˜¯Reactæ€§èƒ½ä¼˜åŒ–çš„é‡è¦å·¥å…·ä¹‹ä¸€ã€‚æœ¬ç« å°†æ·±å…¥æ¢è®¨React.memoçš„å·¥ä½œåŸç†ã€ä½¿ç”¨åœºæ™¯ã€æ€§èƒ½ä¼˜åŒ–ç­–ç•¥å’Œå®é™…åº”ç”¨ã€‚

## æœ¬ç« å­¦ä¹ ç›®æ ‡

- ç†è§£React.memoçš„å·¥ä½œåŸç†å’Œè®°å¿†åŒ–æœºåˆ¶
- æŒæ¡React.memoçš„åŸºç¡€ç”¨æ³•å’ŒAPI
- å­¦ä¼šä½¿ç”¨React.memoä¼˜åŒ–ç»„ä»¶æ¸²æŸ“æ€§èƒ½
- ç†è§£è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°çš„ä½¿ç”¨
- æŒæ¡React.memoçš„æœ€ä½³å®è·µå’Œå¸¸è§é™·é˜±
- å­¦ä¼šä¸å…¶ä»–æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯ç»“åˆä½¿ç”¨
- ç†è§£React.memoçš„é€‚ç”¨åœºæ™¯å’Œé™åˆ¶
- æŒæ¡æ€§èƒ½åˆ†æå’Œæµ‹é‡æ–¹æ³•

---

## 1. React.memoåŸºç¡€æ¦‚å¿µ

React.memoæ˜¯ä¸€ä¸ªé«˜é˜¶ç»„ä»¶ï¼Œå®ƒä¼šè®°ä½ç»„ä»¶çš„æ¸²æŸ“ç»“æœï¼Œå¹¶åœ¨ç›¸åŒçš„propsä¸‹è·³è¿‡æ¸²æŸ“ï¼Œç›´æ¥è¿”å›ä¸Šä¸€æ¬¡çš„æ¸²æŸ“ç»“æœã€‚

<Box style={{ padding: '20px', background: '#e3f2fd', borderRadius: '8px', margin: '20px 0' }}>
  <h4 style={{ margin: 0, color: '#1976d2' }}>ğŸ’¡ æ ¸å¿ƒç†å¿µ</h4>
  <p style={{ margin: '10px 0 0 0' }}>
    <strong>è®°å¿†åŒ–æ¸²æŸ“</strong> - ç¼“å­˜ç»„ä»¶çš„æ¸²æŸ“ç»“æœ<br />
    <strong>é¿å…é‡å¤è®¡ç®—</strong> - è·³è¿‡ä¸å¿…è¦çš„æ¸²æŸ“è¿‡ç¨‹<br />
    <strong>æ™ºèƒ½æ¯”è¾ƒ</strong> - æµ…æ¯”è¾ƒpropså˜åŒ–<br />
    <strong>æå‡æ€§èƒ½</strong> - å‡å°‘DOMæ“ä½œå’Œè®¡ç®—å¼€é”€
  </p>
</Box>

<CodeBlock>

```jsx
// åŸºç¡€ç”¨æ³•
import React from 'react';

// æœªä¼˜åŒ–çš„ç»„ä»¶ - æ¯æ¬¡çˆ¶ç»„ä»¶æ›´æ–°éƒ½ä¼šé‡æ–°æ¸²æŸ“
function UserComponent({ user, onUpdate }) {
  console.log('UserComponent rendered');
  return (
    <div>
      <h3>{user.name}</h3>
      <p>Email: {user.email}</p>
      <button onClick={() => onUpdate(user.id)}>Update</button>
    </div>
  );
}

// ä½¿ç”¨React.memoä¼˜åŒ–
const MemoizedUserComponent = React.memo(UserComponent);

// ä½¿ç”¨
function App() {
  const [user, setUser] = React.useState({ name: 'John', email: 'john@example.com' });
  const [count, setCount] = React.useState(0);

  const handleUpdate = (id) => {
    console.log('Update called for', id);
  };

  return (
    <div>
      {/* countå˜åŒ–ä¼šè§¦å‘Appé‡æ–°æ¸²æŸ“ï¼Œä½†MemoizedUserComponentä¸ä¼šé‡æ–°æ¸²æŸ“ */}
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>

      {/* åªæœ‰userå˜åŒ–æ—¶æ‰ä¼šé‡æ–°æ¸²æŸ“ */}
      <MemoizedUserComponent user={user} onUpdate={handleUpdate} />
    </div>
  );
}
```

</CodeBlock>

### 1.1 React.memoçš„å·¥ä½œåŸç†

<CodeBlock>

```jsx
// React.memoçš„ç®€åŒ–å®ç°
function myMemo(Component) {
  const MemoizedComponent = React.forwardRef((props, ref) => {
    const prevProps = useRef(null);

    // æµ…æ¯”è¾ƒå½“å‰propså’Œä¸Šä¸€æ¬¡çš„props
    const areEqual = (prevProps, nextProps) => {
      if (prevProps === null) {
        return false;
      }

      const prevKeys = Object.keys(prevProps);
      const nextKeys = Object.keys(nextProps);

      if (prevKeys.length !== nextKeys.length) {
        return false;
      }

      // æµ…æ¯”è¾ƒï¼šåªæ¯”è¾ƒç¬¬ä¸€å±‚
      for (let key of prevKeys) {
        if (prevProps[key] !== nextProps[key]) {
          return false;
        }
      }

      return true;
    };

    // ä½¿ç”¨useRefç¼“å­˜ä¸Šä¸€æ¬¡props
    if (!areEqual(prevProps.current, props)) {
      prevProps.current = props;
    }

    // å¦‚æœpropsæ²¡æœ‰å˜åŒ–ï¼Œè·³è¿‡æ¸²æŸ“
    if (areEqual(prevProps.current, props) && prevProps.current !== null) {
      return null; // æˆ–è¿”å›ä¸Šä¸€æ¬¡çš„æ¸²æŸ“ç»“æœ
    }

    // propså˜åŒ–ï¼Œæ­£å¸¸æ¸²æŸ“
    return <Component {...props} ref={ref} />;
  });

  MemoizedComponent.displayName = `Memoized(${Component.displayName || Component.name})`;
  return MemoizedComponent;
}
```

</CodeBlock>

### 1.2 ä½•æ—¶ä½¿ç”¨React.memo
<CodeBlock>

<Grid>

<div>
  <h4>âœ… é€‚åˆä½¿ç”¨React.memoçš„åœºæ™¯</h4>
  <ul>
    <li>ç»„ä»¶æ¸²æŸ“å¼€é”€å¤§</li>
    <li>ç»„ä»¶æ¥æ”¶å¤æ‚props</li>
    <li>ç»„ä»¶åœ¨å¤šå¤„ä½¿ç”¨</li>
    <li>æ•°æ®å˜åŒ–é¢‘ç‡ä½</li>
    <li>ç»„ä»¶æ ‘æ·±å±‚åµŒå¥—</li>
    <li>åˆ—è¡¨ä¸­çš„å­ç»„ä»¶</li>
  </ul>
</div>

<div>
  <h4>âŒ ä¸éœ€è¦React.memoçš„åœºæ™¯</h4>
  <ul>
    <li>çº¯å‡½æ•°ç»„ä»¶ç®€å•</li>
    <li>ç»„ä»¶çŠ¶æ€å˜åŒ–é¢‘ç¹</li>
    <li>ç»„ä»¶æ¯æ¬¡propséƒ½ä¸åŒ</li>
    <li>ç»„ä»¶æ¸²æŸ“éå¸¸å¿«</li>
    <li>æ²¡æœ‰æ€§èƒ½é—®é¢˜</li>
    <li>ç»„ä»¶æ˜¯å¶å­èŠ‚ç‚¹</li>
  </ul>
</div>

</Grid>

</CodeBlock>

<CodeBlock>

```jsx
// åœºæ™¯1ï¼šå¤æ‚åˆ—è¡¨ä¸­çš„ç»„ä»¶
function ListItem({ item, onSelect }) {
  // åªæœ‰itemå˜åŒ–æ—¶æ‰é‡æ–°æ¸²æŸ“
  return (
    <div onClick={() => onSelect(item.id)}>
      <h4>{item.title}</h4>
      <p>{item.description}</p>
    </div>
  );
}

const MemoizedListItem = React.memo(ListItem);

// åœºæ™¯2ï¼šç”¨æˆ·ç•Œé¢ç»„ä»¶
function UserProfile({ user, onEdit }) {
  // ç”¨æˆ·ä¿¡æ¯ä¸ç»å¸¸å˜åŒ–ï¼Œé€‚åˆmemo
  return (
    <div className="profile">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.bio}</p>
      <button onClick={onEdit}>Edit Profile</button>
    </div>
  );
}

const MemoizedUserProfile = React.memo(UserProfile);

// åœºæ™¯3ï¼šè¡¨å•ç»„ä»¶
function FormField({ label, value, onChange, error }) {
  // è¡¨å•å­—æ®µé€šå¸¸ä¸éœ€è¦memoï¼Œå› ä¸ºå®ƒä»¬ç»å¸¸å˜åŒ–
  return (
    <div className="form-field">
      <label>{label}</label>
      <input value={value} onChange={onChange} />
      {error && <span className="error">{error}</span>}
    </div>
  );
}

// ä¸éœ€è¦memoçš„ç»„ä»¶ - æ¯æ¬¡è¾“å…¥éƒ½ä¼šå˜åŒ–
```

</CodeBlock>

---

## 2. React.memo APIè¯¦è§£

### 2.1 åŸºæœ¬è¯­æ³•

<CodeBlock>

```jsx
// è¯­æ³•
const MemoizedComponent = React.memo(Component, areEqual?);

// å‚æ•°
// Component: éœ€è¦ä¼˜åŒ–çš„ç»„ä»¶
// areEqual: å¯é€‰çš„è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°(prevProps, nextProps) => boolean

// è¿”å›å€¼
// è¿”å›ä¸€ä¸ªè®°å¿†åŒ–çš„ç»„ä»¶
```

</CodeBlock>

### 2.2 ç®€å•ç¤ºä¾‹

<CodeBlock>

```jsx
// ç¤ºä¾‹1ï¼šåŸºç¡€ç”¨æ³•
function Button({ children, onClick, variant = 'primary' }) {
  return (
    <button
      className={`btn btn-${variant}`}
      onClick={onClick}
    >
      {children}
    </button>
  );
}

// ä½¿ç”¨React.memoä¼˜åŒ–
const MemoizedButton = React.memo(Button);

// ä½¿ç”¨
function App() {
  const [count, setCount] = useState(0);

  // æ¯æ¬¡countå˜åŒ–ï¼ŒAppä¼šé‡æ–°æ¸²æŸ“
  // ä½†MemoizedButtonä¸ä¼šé‡æ–°æ¸²æŸ“ï¼Œå› ä¸ºpropsæ²¡æœ‰å˜åŒ–
  return (
    <div>
      <MemoizedButton onClick={() => setCount(c => c + 1)}>
        Count: {count}
      </MemoizedButton>
    </div>
  );
}
```

</CodeBlock>

### 2.3 è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°

<CodeBlock>

```jsx
// è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°ç¤ºä¾‹
function UserCard({ user, onEdit, onDelete }) {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>Edit</button>
      <button onClick={() => onDelete(user.id)}>Delete</button>
    </div>
  );
}

// åœºæ™¯1ï¼šåªå…³å¿ƒuserå¯¹è±¡å˜åŒ–
const MemoizedUserCard1 = React.memo(UserCard, (prevProps, nextProps) => {
  return prevProps.user.id === nextProps.user.id &&
         prevProps.user.name === nextProps.user.name &&
         prevProps.user.email === nextProps.user.email;
});

// åœºæ™¯2ï¼šå¿½ç•¥æŸäº›propså˜åŒ–
const MemoizedUserCard2 = React.memo(UserCard, (prevProps, nextProps) => {
  // å¿½ç•¥onEditå’ŒonDeleteçš„å˜åŒ–
  return prevProps.user.id === nextProps.user.id &&
         prevProps.user.name === nextProps.user.name &&
         prevProps.user.email === nextProps.user.email;
});

// åœºæ™¯3ï¼šæ·±åº¦æ¯”è¾ƒ
const MemoizedUserCard3 = React.memo(UserCard, (prevProps, nextProps) => {
  return JSON.stringify(prevProps.user) === JSON.stringify(nextProps.user);
});

// åœºæ™¯4ï¼šä¼˜åŒ–æ·±åº¦æ¯”è¾ƒçš„æ€§èƒ½
const MemoizedUserCard4 = React.memo(UserCard, (prevProps, nextProps) => {
  return (
    prevProps.user.id === nextProps.user.id &&
    prevProps.user.name === nextProps.user.name &&
    prevProps.user.email === nextProps.user.email &&
    prevProps.user.address.city === nextProps.user.address.city
  );
});
```

</CodeBlock>

### 2.4 æ€§èƒ½æ¯”è¾ƒç¤ºä¾‹

<CodeBlock>

```jsx
// æ€§èƒ½å¯¹æ¯”ç¤ºä¾‹
function ExpensiveComponent({ data, onUpdate }) {
  // æ¨¡æ‹Ÿæ˜‚è´µçš„è®¡ç®—
  const processedData = React.useMemo(() => {
    console.log('Expensive calculation performed');
    return data.map(item => ({
      ...item,
      processed: true,
      timestamp: Date.now()
    }));
  }, [data]);

  return (
    <div>
      {processedData.map(item => (
        <div key={item.id}>
          {item.name} - {item.value}
        </div>
      ))}
    </div>
  );
}

const MemoizedExpensiveComponent = React.memo(ExpensiveComponent);

function App() {
  const [count, setCount] = useState(0);
  const [data, setData] = useState([
    { id: 1, name: 'Item 1', value: 10 },
    { id: 2, name: 'Item 2', value: 20 }
  ]);

  // æµ‹è¯•æ€§èƒ½
  React.useEffect(() => {
    const start = performance.now();
    // å¤šæ¬¡æ¸²æŸ“æµ‹è¯•
    for (let i = 0; i < 1000; i++) {
      setCount(c => c + 1);
    }
    const end = performance.now();
    console.log(`Total time: ${end - start}ms`);
  }, []);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>
        Increment: {count}
      </button>
      {/* ç‚¹å‡»æŒ‰é’®ä¼šè§¦å‘Appé‡æ–°æ¸²æŸ“ï¼Œä½†MemoizedExpensiveComponentä¸ä¼šé‡æ–°æ¸²æŸ“ */}
      <MemoizedExpensiveComponent data={data} onUpdate={() => {}} />
    </div>
  );
}
```

</CodeBlock>

---

## 3. é«˜çº§ç”¨æ³•å’Œæ¨¡å¼

### 3.1 ä¸useCallbackå’ŒuseMemoç»“åˆ

<CodeBlock>

```jsx
// ç»„åˆä½¿ç”¨ç¤ºä¾‹
function TodoList({ todos, filter, onToggle, onDelete, onAdd }) {
  const [newTodo, setNewTodo] = useState('');

  // ä½¿ç”¨useMemoä¼˜åŒ–è¿‡æ»¤é€»è¾‘
  const filteredTodos = useMemo(() => {
    return todos.filter(todo => {
      if (filter === 'active') return !todo.completed;
      if (filter === 'completed') return todo.completed;
      return true;
    });
  }, [todos, filter]);

  // ä½¿ç”¨useCallbackä¼˜åŒ–äº‹ä»¶å¤„ç†å™¨
  const handleToggle = useCallback((id) => {
    onToggle(id);
  }, [onToggle]);

  const handleDelete = useCallback((id) => {
    onDelete(id);
  }, [onDelete]);

  const handleAdd = useCallback(() => {
    onAdd(newTodo);
    setNewTodo('');
  }, [newTodo, onAdd]);

  // ä½¿ç”¨React.memoä¼˜åŒ–åˆ—è¡¨é¡¹
  const TodoItem = ({ todo }) => (
    <div>
      <span
        style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}
        onClick={() => handleToggle(todo.id)}
      >
        {todo.text}
      </span>
      <button onClick={() => handleDelete(todo.id)}>Delete</button>
    </div>
  );

  const MemoizedTodoItem = React.memo(TodoItem);

  return (
    <div>
      <input
        value={newTodo}
        onChange={(e) => setNewTodo(e.target.value)}
        placeholder="Add new todo"
      />
      <button onClick={handleAdd}>Add</button>

      <div>
        {filteredTodos.map(todo => (
          <MemoizedTodoItem key={todo.id} todo={todo} />
        ))}
      </div>
    </div>
  );
}

const MemoizedTodoList = React.memo(TodoList);
```

</CodeBlock>

### 3.2 åŠ¨æ€ç»„ä»¶

<CodeBlock>

```jsx
// åŠ¨æ€ç»„ä»¶ä¼˜åŒ–
function DynamicComponent({ type, data, onUpdate }) {
  const components = {
    chart: ChartComponent,
    table: TableComponent,
    list: ListComponent
  };

  const Component = components[type];

  return (
    <div>
      <Component data={data} onUpdate={onUpdate} />
    </div>
  );
}

// ä¼˜åŒ–åŠ¨æ€ç»„ä»¶
const MemoizedDynamicComponent = React.memo(DynamicComponent, (prevProps, nextProps) => {
  return prevProps.type === nextProps.type &&
         JSON.stringify(prevProps.data) === JSON.stringify(nextProps.data);
});

function ChartComponent({ data, onUpdate }) {
  // å›¾è¡¨ç»„ä»¶å®ç°
  return <div>Chart rendering...</div>;
}

const MemoizedChartComponent = React.memo(ChartComponent);

function TableComponent({ data, onUpdate }) {
  // è¡¨æ ¼ç»„ä»¶å®ç°
  return <div>Table rendering...</div>;
}

const MemoizedTableComponent = React.memo(TableComponent);

function ListComponent({ data, onUpdate }) {
  // åˆ—è¡¨ç»„ä»¶å®ç°
  return <div>List rendering...</div>;
}

const MemoizedListComponent = React.memo(ListComponent);
```

</CodeBlock>

### 3.3 æ¡ä»¶æ¸²æŸ“ä¼˜åŒ–

<CodeBlock>

```jsx
// æ¡ä»¶æ¸²æŸ“ä¼˜åŒ–
function ConditionalRender({ condition, data, fallback }) {
  const [showData, setShowData] = useState(false);

  const DataComponent = useMemo(() => {
    return React.memo(({ data }) => (
      <div>
        <h3>Data Component</h3>
        <p>Data: {JSON.stringify(data)}</p>
      </div>
    ));
  }, []);

  if (condition && !showData) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      {condition ? (
        <DataComponent data={data} />
      ) : (
        <div>{fallback}</div>
      )}
      <button onClick={() => setShowData(true)}>
        Show Data
      </button>
    </div>
  );
}

const MemoizedConditionalRender = React.memo(ConditionalRender);

// æ‡’åŠ è½½ä¼˜åŒ–
function LazyComponent({ data }) {
  const LazyLoadedComponent = useMemo(() => {
    return React.lazy(() => import('./HeavyComponent'));
  }, []);

  return (
    <div>
      {data && (
        <Suspense fallback={<div>Loading...</div>}>
          <LazyLoadedComponent data={data} />
        </Suspense>
      )}
    </div>
  );
}

const MemoizedLazyComponent = React.memo(LazyComponent);
```

</CodeBlock>

---

## 4. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 4.1 ç»„ä»¶æ‹†åˆ†ç­–ç•¥

<CodeBlock>

```jsx
// ç­–ç•¥1ï¼šæ‹†åˆ†å¤§å‹ç»„ä»¶
function LargeComponent({ user, posts, comments, onUpdateUser, onAddPost, onAddComment }) {
  // é—®é¢˜ï¼šä»»ä½•propså˜åŒ–éƒ½ä¼šå¯¼è‡´æ•´ä¸ªç»„ä»¶é‡æ–°æ¸²æŸ“
  return (
    <div>
      <UserSection user={user} onUpdate={onUpdateUser} />
      <PostSection posts={posts} onAdd={onAddPost} />
      <CommentSection comments={comments} onAdd={onAddComment} />
    </div>
  );
}

// è§£å†³ï¼šæ‹†åˆ†ä¸ºå°ç»„ä»¶å¹¶ä½¿ç”¨React.memo
const UserSection = React.memo(({ user, onUpdate }) => (
  <div>
    <h2>User Profile</h2>
    <p>Name: {user.name}</p>
    <button onClick={onUpdate}>Update Profile</button>
  </div>
));

const PostSection = React.memo(({ posts, onAdd }) => (
  <div>
    <h2>Posts ({posts.length})</h2>
    <ul>
      {posts.map(post => <li key={post.id}>{post.title}</li>)}
    </ul>
    <button onClick={onAdd}>Add Post</button>
  </div>
));

const CommentSection = React.memo(({ comments, onAdd }) => (
  <div>
    <h2>Comments ({comments.length})</h2>
    <ul>
      {comments.map(comment => <li key={comment.id}>{comment.text}</li>)}
    </ul>
    <button onClick={onAdd}>Add Comment</button>
  </div>
));

function OptimizedLargeComponent(props) {
  return (
    <div>
      <UserSection {...props} />
      <PostSection {...props} />
      <CommentSection {...props} />
    </div>
  );
}
```

</CodeBlock>

### 4.2 åˆ—è¡¨ä¼˜åŒ–

<CodeBlock>

```jsx
// åˆ—è¡¨ä¼˜åŒ–ç­–ç•¥
function OptimizedList({ items, onItemClick, onItemDelete }) {
  // ç­–ç•¥1ï¼šä½¿ç”¨React.memoä¼˜åŒ–åˆ—è¡¨é¡¹
  const ListItem = React.memo(({ item, onClick, onDelete }) => (
    <div className="list-item">
      <span onClick={() => onClick(item.id)}>
        {item.name}
      </span>
      <button onClick={() => onDelete(item.id)}>Delete</button>
    </div>
  ));

  // ç­–ç•¥2ï¼šä½¿ç”¨useCallbackä¼˜åŒ–äº‹ä»¶å¤„ç†å™¨
  const handleClick = useCallback((id) => {
    onItemClick(id);
  }, [onItemClick]);

  const handleDelete = useCallback((id) => {
    onItemDelete(id);
  }, [onItemDelete]);

  // ç­–ç•¥3ï¼šä½¿ç”¨keyä¼˜åŒ–
  return (
    <div>
      {items.map(item => (
        <ListItem
          key={item.id}
          item={item}
          onClick={handleClick}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}

// é«˜çº§åˆ—è¡¨ä¼˜åŒ–ï¼šè™šæ‹ŸåŒ–
function VirtualizedList({ items, itemHeight, visibleItems }) {
  const [scrollTop, setScrollTop] = useState(0);

  const startIndex = useMemo(() => {
    return Math.floor(scrollTop / itemHeight);
  }, [scrollTop, itemHeight]);

  const endIndex = useMemo(() => {
    return Math.min(startIndex + visibleItems, items.length);
  }, [startIndex, visibleItems, items.length]);

  const visibleItemsSlice = useMemo(() => {
    return items.slice(startIndex, endIndex);
  }, [items, startIndex, endIndex]);

  const ListItem = React.memo(({ item, index }) => (
    <div style={{ height: itemHeight }}>
      {item.name}
    </div>
  ));

  return (
    <div
      style={{ height: itemHeight * visibleItems, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        {visibleItemsSlice.map((item, index) => (
          <div
            key={item.id}
            style={{
              position: 'absolute',
              top: (startIndex + index) * itemHeight,
              height: itemHeight
            }}
          >
            <ListItem item={item} index={startIndex + index} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

</CodeBlock>

### 4.3 çŠ¶æ€ç»“æ„ä¼˜åŒ–

<CodeBlock>

```jsx
// ç­–ç•¥ï¼šæ‰å¹³åŒ–çŠ¶æ€ç»“æ„
function BadStateStructure() {
  // é—®é¢˜ï¼šæ·±å±‚åµŒå¥—ï¼Œæ¯æ¬¡æ›´æ–°éƒ½åˆ›å»ºæ–°å¯¹è±¡
  const [state, setState] = useState({
    user: {
      profile: {
        name: '',
        email: ''
      },
      preferences: {
        theme: 'light',
        language: 'en'
      }
    },
    data: []
  });

  const updateName = (name) => {
    setState(prev => ({
      ...prev,
      user: {
        ...prev.user,
        profile: {
          ...prev.user.profile,
          name
        }
      }
    }));
  };

  return (
    <div>
      <input
        value={state.user.profile.name}
        onChange={(e) => updateName(e.target.value)}
      />
    </div>
  );
}

function GoodStateStructure() {
  // è§£å†³ï¼šæ‰å¹³åŒ–çŠ¶æ€ï¼Œåªæ›´æ–°éœ€è¦çš„éƒ¨åˆ†
  const [userName, setUserName] = useState('');
  const [userEmail, setUserEmail] = useState('');
  const [theme, setTheme] = useState('light');
  const [language, setLanguage] = useState('en');
  const [data, setData] = useState([]);

  return (
    <div>
      <ProfileSection
        name={userName}
        email={userEmail}
        onNameChange={setUserName}
        onEmailChange={setUserEmail}
      />
      <PreferencesSection
        theme={theme}
        language={language}
        onThemeChange={setTheme}
        onLanguageChange={setLanguage}
      />
    </div>
  );
}

const ProfileSection = React.memo(({ name, email, onNameChange, onEmailChange }) => (
  <div>
    <input value={name} onChange={(e) => onNameChange(e.target.value)} />
    <input value={email} onChange={(e) => onEmailChange(e.target.value)} />
  </div>
));

const PreferencesSection = React.memo(({ theme, language, onThemeChange, onLanguageChange }) => (
  <div>
    <select value={theme} onChange={(e) => onThemeChange(e.target.value)}>
      <option value="light">Light</option>
      <option value="dark">Dark</option>
    </select>
    <select value={language} onChange={(e) => onLanguageChange(e.target.value)}>
      <option value="en">English</option>
      <option value="zh">ä¸­æ–‡</option>
    </select>
  </div>
));
```

</CodeBlock>

---

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ

<CodeBlock>

```jsx
// å®Œæ•´çš„ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ
const UserList = React.memo(({ users, onSelect, onDelete, selectedId }) => {
  return (
    <div className="user-list">
      {users.map(user => (
        <UserItem
          key={user.id}
          user={user}
          isSelected={user.id === selectedId}
          onSelect={() => onSelect(user.id)}
          onDelete={() => onDelete(user.id)}
        />
      ))}
    </div>
  );
});

const UserItem = React.memo(({ user, isSelected, onSelect, onDelete }) => {
  return (
    <div
      className={`user-item ${isSelected ? 'selected' : ''}`}
      onClick={onSelect}
    >
      <img src={user.avatar} alt={user.name} />
      <div className="user-info">
        <h3>{user.name}</h3>
        <p>{user.email}</p>
      </div>
      <button onClick={(e) => { e.stopPropagation(); onDelete(); }}>
        Delete
      </button>
    </div>
  );
});

const UserDetails = React.memo(({ user, onEdit, onUpdate }) => {
  if (!user) {
    return <div>Select a user to view details</div>;
  }

  return (
    <div className="user-details">
      <h2>{user.name}</h2>
      <p>Email: {user.email}</p>
      <p>Role: {user.role}</p>
      <button onClick={onEdit}>Edit</button>
      <button onClick={onUpdate}>Update</button>
    </div>
  );
});

function UserManagement() {
  const [users, setUsers] = useState([]);
  const [selectedId, setSelectedId] = useState(null);
  const [editingUser, setEditingUser] = useState(null);

  const selectedUser = useMemo(() => {
    return users.find(user => user.id === selectedId);
  }, [users, selectedId]);

  const handleSelect = useCallback((id) => {
    setSelectedId(id);
  }, []);

  const handleDelete = useCallback((id) => {
    setUsers(prev => prev.filter(user => user.id !== id));
    if (selectedId === id) {
      setSelectedId(null);
    }
  }, [selectedId]);

  const handleEdit = useCallback((user) => {
    setEditingUser(user);
  }, []);

  const handleUpdate = useCallback((userId, updates) => {
    setUsers(prev => prev.map(user =>
      user.id === userId ? { ...user, ...updates } : user
    ));
  }, []);

  return (
    <div className="user-management">
      <div className="user-list-container">
        <h2>Users</h2>
        <UserList
          users={users}
          selectedId={selectedId}
          onSelect={handleSelect}
          onDelete={handleDelete}
        />
      </div>
      <div className="user-details-container">
        <UserDetails
          user={selectedUser}
          onEdit={() => handleEdit(selectedUser)}
          onUpdate={() => handleUpdate(selectedUser.id, { updated: true })}
        />
      </div>
    </div>
  );
}
```

</CodeBlock>

### 5.2 è´­ç‰©è½¦ç³»ç»Ÿ

<CodeBlock>

```jsx
// è´­ç‰©è½¦ç³»ç»Ÿä¼˜åŒ–
const CartItem = React.memo(({ item, onUpdateQuantity, onRemove }) => {
  const { id, name, price, quantity, image } = item;

  const handleQuantityChange = useCallback((newQuantity) => {
    if (newQuantity <= 0) {
      onRemove(id);
    } else {
      onUpdateQuantity(id, newQuantity);
    }
  }, [id, onUpdateQuantity, onRemove]);

  const total = useMemo(() => {
    return price * quantity;
  }, [price, quantity]);

  return (
    <div className="cart-item">
      <img src={image} alt={name} />
      <div className="item-details">
        <h3>{name}</h3>
        <p>Price: ${price}</p>
        <p>Total: ${total}</p>
      </div>
      <div className="quantity-controls">
        <button onClick={() => handleQuantityChange(quantity - 1)}>-</button>
        <span>{quantity}</span>
        <button onClick={() => handleQuantityChange(quantity + 1)}>+</button>
      </div>
      <button onClick={() => onRemove(id)}>Remove</button>
    </div>
  );
});

const CartSummary = React.memo(({ items, onCheckout }) => {
  const { totalItems, totalPrice } = useMemo(() => {
    const totalItems = items.reduce((sum, item) => sum + item.quantity, 0);
    const totalPrice = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
    return { totalItems, totalPrice };
  }, [items]);

  return (
    <div className="cart-summary">
      <h3>Cart Summary</h3>
      <p>Total Items: {totalItems}</p>
      <p>Total Price: ${totalPrice}</p>
      <button onClick={onCheckout} disabled={items.length === 0}>
        Checkout
      </button>
    </div>
  );
});

function ShoppingCart() {
  const [items, setItems] = useState([]);

  const handleUpdateQuantity = useCallback((id, quantity) => {
    setItems(prev => prev.map(item =>
      item.id === id ? { ...item, quantity } : item
    ));
  }, []);

  const handleRemove = useCallback((id) => {
    setItems(prev => prev.filter(item => item.id !== id));
  }, []);

  const handleCheckout = useCallback(() => {
    console.log('Proceeding to checkout...');
    // ç»“ç®—é€»è¾‘
  }, []);

  return (
    <div className="shopping-cart">
      <h2>Shopping Cart</h2>
      <div className="cart-items">
        {items.map(item => (
          <CartItem
            key={item.id}
            item={item}
            onUpdateQuantity={handleUpdateQuantity}
            onRemove={handleRemove}
          />
        ))}
      </div>
      <CartSummary items={items} onCheckout={handleCheckout} />
    </div>
  );
}
```

</CodeBlock>

### 5.3 æ•°æ®å¯è§†åŒ–ç»„ä»¶

<CodeBlock>

```jsx
// æ•°æ®å¯è§†åŒ–ä¼˜åŒ–
const ChartContainer = React.memo(({ data, type, width, height }) => {
  const processedData = useMemo(() => {
    // é¢„å¤„ç†æ•°æ®
    return data.map(item => ({
      ...item,
      normalized: (item.value - item.min) / (item.max - item.min)
    }));
  }, [data]);

  const ChartComponent = useMemo(() => {
    const components = {
      line: LineChart,
      bar: BarChart,
      pie: PieChart
    };
    return components[type] || LineChart;
  }, [type]);

  return (
    <div className="chart-container" style={{ width, height }}>
      <ChartComponent data={processedData} />
    </div>
  );
});

const DataPoint = React.memo(({ point, onHover, onClick }) => {
  return (
    <circle
      cx={point.x}
      cy={point.y}
      r={point.r}
      fill={point.color}
      onMouseEnter={() => onHover(point)}
      onClick={() => onClick(point)}
    />
  );
});

const Tooltip = React.memo(({ visible, position, content }) => {
  if (!visible) return null;

  return (
    <div
      className="tooltip"
      style={{
        left: position.x,
        top: position.y
      }}
    >
      {content}
    </div>
  );
});

function Dashboard() {
  const [data, setData] = useState([]);
  const [selectedChart, setSelectedChart] = useState('line');
  const [hoveredPoint, setHoveredPoint] = useState(null);

  const chartData = useMemo(() => {
    // ç”Ÿæˆç¤ºä¾‹æ•°æ®
    return Array.from({ length: 50 }, (_, i) => ({
      id: i,
      value: Math.random() * 100,
      x: i * 20,
      y: Math.random() * 200
    }));
  }, []);

  const handleHover = useCallback((point) => {
    setHoveredPoint(point);
  }, []);

  const handleClick = useCallback((point) => {
    console.log('Point clicked:', point);
  }, []);

  return (
    <div className="dashboard">
      <div className="chart-controls">
        <button onClick={() => setSelectedChart('line')}>Line Chart</button>
        <button onClick={() => setSelectedChart('bar')}>Bar Chart</button>
        <button onClick={() => setSelectedChart('pie')}>Pie Chart</button>
      </div>
      <ChartContainer
        data={chartData}
        type={selectedChart}
        width={800}
        height={400}
      />
      <Tooltip
        visible={!!hoveredPoint}
        position={{ x: hoveredPoint?.x || 0, y: hoveredPoint?.y || 0 }}
        content={`Value: ${hoveredPoint?.value}`}
      />
    </div>
  );
}
```

</CodeBlock>

---

## 6. æ€§èƒ½ç›‘æ§å’Œåˆ†æ

### 6.1 æ€§èƒ½æµ‹é‡

<CodeBlock>

```jsx
// æ€§èƒ½æµ‹é‡å·¥å…·
function withPerformanceMonitoring(WrappedComponent) {
  return React.memo((props) => {
    const renderCount = useRef(0);
    const lastRenderTime = useRef(performance.now());

    renderCount.current += 1;
    const currentTime = performance.now();
    const renderTime = currentTime - lastRenderTime.current;
    lastRenderTime.current = currentTime;

    useEffect(() => {
      console.log(`${WrappedComponent.name} rendered ${renderCount.current} times`);
      console.log(`Last render time: ${renderTime.toFixed(2)}ms`);
    });

    return <WrappedComponent {...props} />;
  });
}

// ä½¿ç”¨ç¤ºä¾‹
const MonitoredComponent = withPerformanceMonitoring(({ data }) => {
  return <div>{data.map(item => <p key={item.id}>{item.name}</p>)}</div>;
});

// æ€§èƒ½åˆ†æHook
function usePerformanceMonitor(componentName) {
  const renderCount = useRef(0);
  const renderTimes = useRef([]);

  renderCount.current += 1;
  const startTime = performance.now();

  useEffect(() => {
    const endTime = performance.now();
    const renderTime = endTime - startTime;
    renderTimes.current.push(renderTime);

    const avgRenderTime = renderTimes.current.reduce((a, b) => a + b, 0) / renderTimes.current.length;

    console.log(`[${componentName}] Render #${renderCount.current}: ${renderTime.toFixed(2)}ms (avg: ${avgRenderTime.toFixed(2)}ms)`);

    return () => {
      // æ¸…ç†å†å²æ•°æ®
      if (renderTimes.current.length > 100) {
        renderTimes.current = [];
        renderCount.current = 0;
      }
    };
  });
}

const OptimizedComponent = React.memo(({ data }) => {
  usePerformanceMonitor('OptimizedComponent');

  return (
    <div>
      {data.map(item => <div key={item.id}>{item.name}</div>)}
    </div>
  );
});
```

</CodeBlock>

### 6.2 React DevTools Profiler

<CodeBlock>

```jsx
// ä½¿ç”¨React DevTools Profiler
import { Profiler } from 'react';

function onRenderCallback(
  id, // the "id" prop of the Profiler tree that has just committed
  phase, // either "mount" (on the initial render) or "update" (on re-renders)
  actualDuration, // time spent rendering the committed update
  baseDuration, // estimated time to render the entire subtree without memoization
  startTime, // when React started rendering this update
  commitTime, // when React committed this update
  interactions // the Set of interactions belonging to this update
) {
  console.log('Profiler:', {
    id,
    phase,
    actualDuration,
    baseDuration,
    startTime,
    commitTime,
    interactions: interactions.size
  });
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <div>
        <HeavyComponent data={data} />
      </div>
    </Profiler>
  );
}

// æ€§èƒ½åˆ†æåŒ…è£…å™¨
function withProfiler(id, WrappedComponent) {
  return (props) => (
    <Profiler id={id} onRender={onRenderCallback}>
      <WrappedComponent {...props} />
    </Profiler>
  );
}

const ProfiledComponent = withProfiler('MyComponent', MyComponent);
```

</CodeBlock>

### 6.3 æ€§èƒ½åŸºå‡†æµ‹è¯•

<CodeBlock>

```jsx
// æ€§èƒ½åŸºå‡†æµ‹è¯•
function benchmarkComponent(Component, props, iterations = 100) {
  const results = [];

  for (let i = 0; i < iterations; i++) {
    const startTime = performance.now();

    // æ¨¡æ‹Ÿç»„ä»¶æ¸²æŸ“
    const element = React.createElement(Component, props);

    // è¿™é‡Œå¯ä»¥æ·»åŠ å®é™…çš„æ¸²æŸ“é€»è¾‘

    const endTime = performance.now();
    results.push(endTime - startTime);
  }

  const avgTime = results.reduce((a, b) => a + b, 0) / results.length;
  const minTime = Math.min(...results);
  const maxTime = Math.max(...results);

  console.log('Benchmark Results:', {
    average: avgTime.toFixed(2) + 'ms',
    min: minTime.toFixed(2) + 'ms',
    max: maxTime.toFixed(2) + 'ms',
    iterations
  });

  return { average: avgTime, min: minTime, max: maxTime };
}

// ä½¿ç”¨ç¤ºä¾‹
function MyComponent({ data }) {
  return <div>{data.map(item => <p key={item.id}>{item.name}</p>)}</div>;
}

const MemoizedMyComponent = React.memo(MyComponent);

// å¯¹æ¯”æ€§èƒ½
const testData = Array.from({ length: 1000 }, (_, i) => ({
  id: i,
  name: `Item ${i}`
}));

console.log('--- Regular Component ---');
benchmarkComponent(MyComponent, { data: testData });

console.log('--- Memoized Component ---');
benchmarkComponent(MemoizedMyComponent, { data: testData });
```

</CodeBlock>

---

## 7. å¸¸è§é™·é˜±å’Œè§£å†³æ–¹æ¡ˆ

### é™·é˜±1ï¼šé”™è¯¯åœ°ä½¿ç”¨React.memo

<ErrorBox>

```jsx
// âŒ é”™è¯¯ï¼šä¸éœ€è¦ä¼˜åŒ–çš„ç»„ä»¶
function SimpleText({ text }) {
  return <p>{text}</p>;
}

const MemoizedSimpleText = React.memo(SimpleText);

// é—®é¢˜ï¼šç»„ä»¶æœ¬èº«å¾ˆç®€å•ï¼Œmemoçš„å¼€é”€å¯èƒ½æ¯”æ¸²æŸ“æ›´å¤§

// âœ… æ­£ç¡®ï¼šåªæœ‰å¤æ‚çš„ç»„ä»¶æ‰ä½¿ç”¨memo
function ComplexDataProcessor({ data, filters, onUpdate }) {
  const processedData = useMemo(() => {
    return data
      .filter(item => filters.includes(item.category))
      .map(item => ({
        ...item,
        processed: true,
        timestamp: Date.now()
      }))
      .sort((a, b) => b.value - a.value);
  }, [data, filters]);

  return (
    <div>
      {processedData.map(item => (
        <DataItem
          key={item.id}
          item={item}
          onUpdate={onUpdate}
        />
      ))}
    </div>
  );
}

const MemoizedComplexDataProcessor = React.memo(ComplexDataProcessor);
```

</ErrorBox>

### é™·é˜±2ï¼špropså˜åŒ–å¯¼è‡´é¢‘ç¹é‡æ¸²æŸ“

<ErrorBox>

```jsx
// âŒ é”™è¯¯ï¼šæ¯æ¬¡æ¸²æŸ“éƒ½åˆ›å»ºæ–°å¯¹è±¡
function BadParent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <Child
        data={{ count, timestamp: Date.now() }} // æ¯æ¬¡éƒ½æ˜¯æ–°å¯¹è±¡ï¼
        onUpdate={() => {}} // æ¯æ¬¡éƒ½æ˜¯æ–°å‡½æ•°ï¼
      />
    </div>
  );
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨useMemoå’ŒuseCallback
function GoodParent() {
  const [count, setCount] = useState(0);

  const data = useMemo(() => ({
    count,
    timestamp: Date.now()
  }), [count]);

  const handleUpdate = useCallback(() => {
    console.log('Update');
  }, []);

  return (
    <div>
      <Child data={data} onUpdate={handleUpdate} />
    </div>
  );
}

const MemoizedChild = React.memo(Child);
```

</ErrorBox>

### é™·é˜±3ï¼šæ·±å±‚åµŒå¥—çš„propsæ¯”è¾ƒ

<ErrorBox>

```jsx
// âŒ é”™è¯¯ï¼šæ·±å±‚åµŒå¥—å¯¹è±¡
function BadExample() {
  const [user, setUser] = useState({
    name: 'John',
    address: {
      city: 'New York',
      zipCode: '10001'
    }
  });

  // æ¯æ¬¡æ›´æ–°éƒ½ä¼šåˆ›å»ºæ–°çš„userå¯¹è±¡
  const updateCity = (city) => {
    setUser(prev => ({
      ...prev,
      address: {
        ...prev.address,
        city
      }
    }));
  };

  return (
    <UserCard user={user} onUpdate={updateCity} />
  );
}

// âœ… æ­£ç¡®ï¼šæ‰å¹³åŒ–çŠ¶æ€æˆ–ä½¿ç”¨è‡ªå®šä¹‰æ¯”è¾ƒ
const UserCard = React.memo(
  ({ user, onUpdate }) => (
    <div>
      <h3>{user.name}</h3>
      <p>City: {user.address.city}</p>
    </div>
  ),
  (prevProps, nextProps) => {
    return prevProps.user.name === nextProps.user.name &&
           prevProps.user.address.city === nextProps.user.address.city &&
           prevProps.user.address.zipCode === nextProps.user.address.zipCode;
  }
);

// æˆ–è€…æ›´ç®€å•ï¼šæ‹†åˆ†çŠ¶æ€
function GoodExample() {
  const [userName, setUserName] = useState('John');
  const [city, setCity] = useState('New York');
  const [zipCode, setZipCode] = useState('10001');

  const user = useMemo(() => ({
    name: userName,
    address: { city, zipCode }
  }), [userName, city, zipCode]);

  return (
    <UserCard user={user} onUpdate={() => {}} />
  );
}

const UserCard = React.memo(({ user }) => (
  <div>
    <h3>{user.name}</h3>
    <p>City: {user.address.city}</p>
  </div>
));
```

</ErrorBox>

### é™·é˜±4ï¼šå¿½ç•¥å‡½æ•°ä¾èµ–

<ErrorBox>

```jsx
// âŒ é”™è¯¯ï¼šuseCallbackä¾èµ–ä¸æ­£ç¡®
function BadComponent({ data, onProcess }) {
  const processedData = useMemo(() => {
    return data.map(item => onProcess(item));
  }, [data, onProcess]); // onProcesså¯èƒ½æ¯æ¬¡éƒ½æ˜¯æ–°å‡½æ•°

  return <div>{processedData.length}</div>;
}

function Parent() {
  const [data, setData] = useState([]);

  const handleProcess = (item) => {
    return {
      ...item,
      processed: true
    };
  };

  return (
    <BadComponent
      data={data}
      onProcess={handleProcess} // æ¯æ¬¡Parentæ¸²æŸ“éƒ½æ˜¯æ–°å‡½æ•°
    />
  );
}

// âœ… æ­£ç¡®ï¼šç¨³å®šåŒ–å‡½æ•°æˆ–ä½¿ç”¨useCallback
function GoodComponent({ data, onProcess }) {
  const processedData = useMemo(() => {
    return data.map(item => onProcess(item));
  }, [data, onProcess]);

  return <div>{processedData.length}</div>;
}

function GoodParent() {
  const [data, setData] = useState([]);

  const handleProcess = useCallback((item) => {
    return {
      ...item,
      processed: true
    };
  }, []); // ç¨³å®šçš„å‡½æ•°

  return (
    <GoodComponent
      data={data}
      onProcess={handleProcess}
    />
  );
}

// æˆ–è€…ä½¿ç”¨useCallbackä¼˜åŒ–Parent
const MemoizedGoodComponent = React.memo(GoodComponent);

function OptimizedParent() {
  const [data, setData] = useState([]);

  const handleProcess = useCallback((item) => {
    return {
      ...item,
      processed: true
    };
  }, []);

  return (
    <MemoizedGoodComponent
      data={data}
      onProcess={handleProcess}
    />
  );
}
```

</ErrorBox>

---

## 8. æœ€ä½³å®è·µ

### 8.1 ä½•æ—¶ä½¿ç”¨React.memo

<BestPractices>

```jsx
// âœ… é€‚åˆä½¿ç”¨React.memoçš„åœºæ™¯

// 1. æ¸²æŸ“å¼€é”€å¤§çš„ç»„ä»¶
function HeavyComponent({ data, calculations }) {
  const result = useMemo(() => {
    // å¤æ‚è®¡ç®—
    return data.reduce((acc, item) => {
      return calculations.reduce((sum, calc) => sum + calc(item), 0);
    }, 0);
  }, [data, calculations]);

  return <div>Result: {result}</div>;
}

const MemoizedHeavyComponent = React.memo(HeavyComponent);

// 2. æ¥æ”¶å¤æ‚propsçš„ç»„ä»¶
function UserProfile({ user, settings, preferences, stats }) {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>Settings: {settings.theme}</p>
      <p>Preferences: {preferences.language}</p>
      <Stats stats={stats} />
    </div>
  );
}

const MemoizedUserProfile = React.memo(UserProfile);

// 3. åˆ—è¡¨ä¸­çš„å­ç»„ä»¶
function ListItem({ item, index, onSelect, onDelete }) {
  return (
    <div>
      <span onClick={() => onSelect(item.id)}>
        {index + 1}. {item.title}
      </span>
      <button onClick={() => onDelete(item.id)}>Delete</button>
    </div>
  );
}

const MemoizedListItem = React.memo(ListItem);

function List({ items }) {
  const handleSelect = useCallback((id) => {
    console.log('Selected:', id);
  }, []);

  const handleDelete = useCallback((id) => {
    console.log('Deleted:', id);
  }, []);

  return (
    <div>
      {items.map((item, index) => (
        <MemoizedListItem
          key={item.id}
          item={item}
          index={index}
          onSelect={handleSelect}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}
```

</BestPractices>

### 8.2 æ€§èƒ½ä¼˜åŒ–åŸåˆ™

<BestPractices>

```jsx
// 1. é¿å…è¿‡åº¦ä¼˜åŒ–
function optimizeComponent(Component) {
  // æ£€æŸ¥ç»„ä»¶æ˜¯å¦çœŸçš„éœ€è¦ä¼˜åŒ–
  if (isSimpleComponent(Component)) {
    return Component; // ä¸è¦ä¼˜åŒ–ç®€å•ç»„ä»¶
  }
  return React.memo(Component);
}

// 2. ç»„åˆä½¿ç”¨ä¼˜åŒ–æŠ€æœ¯
function OptimizedList({ items }) {
  const [filter, setFilter] = useState('');

  // ä½¿ç”¨useMemoä¼˜åŒ–è¿‡æ»¤ç»“æœ
  const filteredItems = useMemo(() => {
    return items.filter(item =>
      item.name.toLowerCase().includes(filter.toLowerCase())
    );
  }, [items, filter]);

  // ä½¿ç”¨useCallbackä¼˜åŒ–äº‹ä»¶å¤„ç†å™¨
  const handleFilterChange = useCallback((e) => {
    setFilter(e.target.value);
  }, []);

  const ListItem = useCallback(({ item }) => (
    <div>{item.name}</div>
  ), []);

  const MemoizedListItem = React.memo(ListItem);

  return (
    <div>
      <input
        value={filter}
        onChange={handleFilterChange}
        placeholder="Filter..."
      />
      <div>
        {filteredItems.map(item => (
          <MemoizedListItem key={item.id} item={item} />
        ))}
      </div>
    </div>
  );
}

// 3. ç›‘æ§æ€§èƒ½
function withPerformanceTracking(Component) {
  return (props) => {
    const renderCount = useRef(0);
    const startTime = useRef(performance.now());

    renderCount.current += 1;

    useEffect(() => {
      const endTime = performance.now();
      const renderTime = endTime - startTime.current;

      if (renderTime > 16) { // è¶…è¿‡ä¸€å¸§çš„æ—¶é—´
        console.warn(
          `${Component.name} render took ${renderTime.toFixed(2)}ms (${renderCount.current} renders)`
        );
      }

      startTime.current = performance.now();
    });

    return <Component {...props} />;
  };
}
```

</BestPractices>

### 8.3 ä»£ç ç»„ç»‡

<BestPractices>

```jsx
// 1. ç»„ä»¶åº“ç»„ç»‡
// components/memoized/index.js
export { default as MemoizedButton } from './MemoizedButton';
export { default as MemoizedInput } from './MemoizedInput';
export { default as MemoizedList } from './MemoizedList';

// components/memoized/MemoizedButton.js
import React from 'react';

function Button({ children, variant = 'primary', ...props }) {
  return (
    <button className={`btn btn-${variant}`} {...props}>
      {children}
    </button>
  );
}

export default React.memo(Button);

// 2. è‡ªå®šä¹‰Hookæ¨¡å¼
function useOptimizedList(items, options = {}) {
  const {
    keyExtractor = item => item.id,
    filterFn = () => true,
    sortFn = (a, b) => 0
  } = options;

  const [filter, setFilter] = useState('');

  const processedItems = useMemo(() => {
    return items
      .filter(item => filterFn(item, filter))
      .sort(sortFn);
  }, [items, filter, filterFn, sortFn]);

  const filteredItems = useMemo(() => {
    return processedItems.filter(item =>
      item.name.toLowerCase().includes(filter.toLowerCase())
    );
  }, [processedItems, filter]);

  const ListItem = useCallback(({ item }) => (
    <div>{item.name}</div>
  ), []);

  const MemoizedListItem = React.memo(ListItem);

  return {
    items: filteredItems,
    filter,
    setFilter,
    ListItem: MemoizedListItem
  };
}

// ä½¿ç”¨
function MyComponent({ data }) {
  const { items, filter, setFilter, ListItem } = useOptimizedList(data);

  return (
    <div>
      <input
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
      />
      {items.map(item => (
        <ListItem key={item.id} item={item} />
      ))}
    </div>
  );
}
```

</BestPractices>

---

## 9. å®è·µç»ƒä¹ 

### ç»ƒä¹ 1ï¼šä¼˜åŒ–ç”¨æˆ·åˆ—è¡¨ç»„ä»¶

<Expandable title="ç‚¹å‡»æŸ¥çœ‹è¦æ±‚">

**åŠŸèƒ½è¦æ±‚**ï¼š
- åˆ›å»ºç”¨æˆ·åˆ—è¡¨æ˜¾ç¤ºç»„ä»¶
- æ”¯æŒç”¨æˆ·é€‰æ‹©å’Œåˆ é™¤
- ä¼˜åŒ–åˆ—è¡¨é¡¹æ¸²æŸ“æ€§èƒ½
- å®ç°æœç´¢å’Œè¿‡æ»¤åŠŸèƒ½

**å®ç°è¦æ±‚**ï¼š
```javascript
// éœ€è¦å®ç°çš„åŠŸèƒ½
const UserList = React.memo(({ users, onSelect, onDelete, selectedId }) => {
  // æ¸²æŸ“ç”¨æˆ·åˆ—è¡¨
});

const UserItem = React.memo(({ user, isSelected, onSelect, onDelete }) => {
  // æ¸²æŸ“å•ä¸ªç”¨æˆ·é¡¹
});

// æ€§èƒ½ä¼˜åŒ–è¦æ±‚
// - ä½¿ç”¨React.memoé¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
// - ä½¿ç”¨useCallbackç¨³å®šäº‹ä»¶å¤„ç†å™¨
// - ä½¿ç”¨useMemoä¼˜åŒ–è®¡ç®—ç»“æœ
// - æ­£ç¡®è®¾ç½®keyå±æ€§
```

**æç¤º**ï¼š
- è€ƒè™‘åˆ—è¡¨é¡¹çš„propså˜åŒ–é¢‘ç‡
- ä½¿ç”¨useCallbackä¼˜åŒ–äº‹ä»¶å¤„ç†å™¨
- ä½¿ç”¨useMemoä¼˜åŒ–å¤æ‚è®¡ç®—
- ç›‘æ§æ¸²æŸ“æ¬¡æ•°

</Expandable>

### ç»ƒä¹ 2ï¼šå®ç°è™šæ‹ŸåŒ–é•¿åˆ—è¡¨

<Expandable title="ç‚¹å‡»æŸ¥çœ‹è¦æ±‚">

**åŠŸèƒ½è¦æ±‚**ï¼š
- åˆ›å»ºå¯æ˜¾ç¤º10000+é¡¹çš„é•¿åˆ—è¡¨
- å®ç°è™šæ‹Ÿæ»šåŠ¨ä¼˜åŒ–
- æ”¯æŒåŠ¨æ€é«˜åº¦åˆ—è¡¨é¡¹
- ä¼˜åŒ–æ»šåŠ¨æ€§èƒ½

**å®ç°è¦æ±‚**ï¼š
```javascript
// éœ€è¦å®ç°çš„åŠŸèƒ½
function VirtualizedList({ items, itemHeight, visibleItems }) {
  const [scrollTop, setScrollTop] = useState(0);

  // è®¡ç®—å¯è§çš„åˆ—è¡¨é¡¹
  const visibleItems = useMemo(() => {
    // è®¡ç®—èµ·å§‹å’Œç»“æŸç´¢å¼•
  }, [scrollTop, itemHeight, items.length]);

  // æ¸²æŸ“ä¼˜åŒ–çš„åˆ—è¡¨é¡¹
  return (
    <div style={{ height: itemHeight * visibleItems, overflow: 'auto' }}>
      <div style={{ height: items.length * itemHeight }}>
        {visibleItems.map((item, index) => (
          // æ¸²æŸ“åˆ—è¡¨é¡¹
        ))}
      </div>
    </div>
  );
}
```

**æç¤º**ï¼š
- åªæ¸²æŸ“è§†çª—å†…çš„åˆ—è¡¨é¡¹
- ä½¿ç”¨position: absoluteå®šä½
- è®¡ç®—æ»šåŠ¨ä½ç½®å’Œå¯è§èŒƒå›´
- ä½¿ç”¨React.memoä¼˜åŒ–åˆ—è¡¨é¡¹

</Expandable>

### ç»ƒä¹ 3ï¼šä¼˜åŒ–æ•°æ®å¯è§†åŒ–ç»„ä»¶

<Expandable title="ç‚¹å‡»æŸ¥çœ‹è¦æ±‚">

**åŠŸèƒ½è¦æ±‚**ï¼š
- åˆ›å»ºå›¾è¡¨ç»„ä»¶ï¼ˆæŠ˜çº¿å›¾ã€æŸ±çŠ¶å›¾ç­‰ï¼‰
- æ”¯æŒæ•°æ®ç‚¹æ‚¬åœæ˜¾ç¤ºè¯¦æƒ…
- å®ç°å›¾è¡¨ç¼©æ”¾å’Œå¹³ç§»
- ä¼˜åŒ–å¤§é‡æ•°æ®ç‚¹çš„æ¸²æŸ“

**å®ç°è¦æ±‚**ï¼š
```javascript
// éœ€è¦å®ç°çš„åŠŸèƒ½
const Chart = React.memo(({ data, type, width, height }) => {
  // å¤„ç†æ•°æ®å¹¶æ¸²æŸ“å›¾è¡¨
});

const DataPoint = React.memo(({ point, onHover, onClick }) => {
  // æ¸²æŸ“å•ä¸ªæ•°æ®ç‚¹
});

const Tooltip = React.memo(({ visible, position, content }) => {
  // æ¸²æŸ“å·¥å…·æç¤º
});

// æ€§èƒ½ä¼˜åŒ–è¦æ±‚
// - ä½¿ç”¨React.memoä¼˜åŒ–ç»„ä»¶
// - ä½¿ç”¨useMemoä¼˜åŒ–æ•°æ®å¤„ç†
// - ä½¿ç”¨useCallbackä¼˜åŒ–äº‹ä»¶å¤„ç†
// - å®ç°é˜²æŠ–å¤„ç†é¼ æ ‡äº‹ä»¶
```

**æç¤º**ï¼š
- å¤§æ•°æ®ç‚¹çš„æ¸²æŸ“ä¼˜åŒ–
- é¼ æ ‡äº‹ä»¶é˜²æŠ–å¤„ç†
- å›¾è¡¨é‡ç»˜ä¼˜åŒ–
- å†…å­˜ä½¿ç”¨ä¼˜åŒ–

</Expandable>

### ç»ƒä¹ 4ï¼šå®ç°æ€§èƒ½ç›‘æ§é¢æ¿

<Expandable title="ç‚¹å‡»æŸ¥çœ‹è¦æ±‚">

**åŠŸèƒ½è¦æ±‚**ï¼š
- åˆ›å»ºæ€§èƒ½ç›‘æ§ç»„ä»¶
- å®æ—¶æ˜¾ç¤ºç»„ä»¶æ¸²æŸ“æ¬¡æ•°
- æ˜¾ç¤ºæ¸²æŸ“æ—¶é—´ç»Ÿè®¡
- æä¾›æ€§èƒ½åˆ†ææŠ¥å‘Š

**å®ç°è¦æ±‚**ï¼š
```javascript
// éœ€è¦å®ç°çš„åŠŸèƒ½
function usePerformanceMonitor(componentName) {
  // è·Ÿè¸ªæ¸²æŸ“æ¬¡æ•°å’Œæ¸²æŸ“æ—¶é—´
}

function PerformanceMonitor({ children }) {
  // æ±‡æ€»æ‰€æœ‰å­ç»„ä»¶çš„æ€§èƒ½æ•°æ®
  // æ˜¾ç¤ºæ€§èƒ½æŠ¥å‘Š
}

// é›†æˆä½¿ç”¨
const MonitoredComponent = withPerformanceTracking(MyComponent);
```

**æç¤º**ï¼š
- ä½¿ç”¨React.useRefå­˜å‚¨æ•°æ®
- ä½¿ç”¨useEffectè¿›è¡Œæ•°æ®é‡‡é›†
- è®¡ç®—å¹³å‡å€¼ã€æœ€å¤§å€¼ã€æœ€å°å€¼
- æä¾›å¯è§†åŒ–å±•ç¤º

</Expandable>

---

## 10. æœ¬ç« å°ç»“

### å…³é”®è¦ç‚¹

<Checklist>

- âœ… React.memoé€šè¿‡è®°å¿†åŒ–é¿å…ä¸å¿…è¦çš„ç»„ä»¶é‡æ–°æ¸²æŸ“
- âœ… React.memoä½¿ç”¨æµ…æ¯”è¾ƒæ¥æ£€æŸ¥propså˜åŒ–
- âœ… è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°å¯ä»¥ç²¾ç¡®æ§åˆ¶ä½•æ—¶é‡æ–°æ¸²æŸ“
- âœ… React.memoé€‚ç”¨äºæ¸²æŸ“å¼€é”€å¤§ã€propså¤æ‚çš„ç»„ä»¶
- âœ… ä¸useCallbackå’ŒuseMemoç»“åˆä½¿ç”¨æ•ˆæœæ›´ä½³
- âœ… æ­£ç¡®ä½¿ç”¨keyå±æ€§å¯¹åˆ—è¡¨æ€§èƒ½è‡³å…³é‡è¦
- âœ… é¿å…åœ¨React.memoç»„ä»¶ä¸­åˆ›å»ºæ–°çš„å¯¹è±¡æˆ–å‡½æ•°
- âœ… æ€§èƒ½ç›‘æ§æ˜¯ä¼˜åŒ–å·¥ä½œçš„é‡è¦ç¯èŠ‚
- âœ… è¿‡åº¦ä¼˜åŒ–å¯èƒ½é€‚å¾—å…¶åï¼Œéœ€è¦æƒè¡¡åˆ©å¼Š
- âœ… æ€§èƒ½ä¼˜åŒ–åº”åŸºäºå®é™…æµ‹é‡è€ŒéçŒœæµ‹

</Checklist>

### React.memoæœ€ä½³å®è·µ

<BestPractices>

1. **é€‚åº¦ä½¿ç”¨** - åªä¼˜åŒ–çœŸæ­£éœ€è¦ä¼˜åŒ–çš„ç»„ä»¶
2. **ç»“åˆå…¶ä»–ä¼˜åŒ–** - ä¸useCallbackã€useMemoé…åˆä½¿ç”¨
3. **ç¨³å®šprops** - é¿å…åœ¨æ¯æ¬¡æ¸²æŸ“æ—¶åˆ›å»ºæ–°å¯¹è±¡
4. **ç›‘æ§æ€§èƒ½** - ä½¿ç”¨Profilerç­‰å·¥å…·æµ‹é‡æ•ˆæœ
5. **ç†è§£é™åˆ¶** - React.memoä¸èƒ½è§£å†³æ‰€æœ‰æ€§èƒ½é—®é¢˜
6. **é¿å…è¿‡åº¦ä¼˜åŒ–** - ç®€å•çš„ç»„ä»¶ä¸éœ€è¦ä¼˜åŒ–
7. **æ­£ç¡®æ¯”è¾ƒ** - è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°éœ€è¦å…¨é¢è€ƒè™‘
8. **çŠ¶æ€ç»“æ„** - æ‰å¹³åŒ–çŠ¶æ€å‡å°‘ä¸å¿…è¦æ›´æ–°

</BestPractices>

### ä½•æ—¶ä½¿ç”¨React.memo

<BestPractices>

**æ¨èä½¿ç”¨**ï¼š
- ç»„ä»¶æ¸²æŸ“å¼€é”€å¤§
- ç»„ä»¶æ¥æ”¶å¤æ‚å¯¹è±¡props
- åˆ—è¡¨ä¸­çš„å­ç»„ä»¶
- æ·±å±‚åµŒå¥—çš„ç»„ä»¶æ ‘
- é¢‘ç¹çˆ¶ç»„ä»¶æ›´æ–°ä½†è‡ªèº«propsä¸å˜

**ä¸éœ€è¦ä½¿ç”¨**ï¼š
- ç®€å•çº¯å‡½æ•°ç»„ä»¶
- ç»„ä»¶çŠ¶æ€ç»å¸¸å˜åŒ–
- ç»„ä»¶æ¸²æŸ“éå¸¸å¿«
- å¶å­èŠ‚ç‚¹ç»„ä»¶
- æ²¡æœ‰æ€§èƒ½é—®é¢˜çš„ç»„ä»¶

</BestPractices>

### ä¸‹ä¸€æ­¥å­¦ä¹ 

ç°åœ¨ä½ å·²ç»æŒæ¡äº†React.memoçš„åŸºç¡€å’Œå®è·µï¼Œæ¥ä¸‹æ¥å¯ä»¥å­¦ä¹ ï¼š

1. **[è™šæ‹ŸåŒ–æŠ€æœ¯](./virtualization)** - å¤§æ•°æ®åˆ—è¡¨ä¼˜åŒ–
2. **[ä»£ç åˆ†å‰²](../advanced/code-splitting)** - åŠ¨æ€å¯¼å…¥å’Œæ‡’åŠ è½½
3. **[æ€§èƒ½ä¼˜åŒ–è¿›é˜¶](../advanced/advanced-optimization)** - æ·±å…¥æ€§èƒ½ä¼˜åŒ–
4. **[React Profilerä½¿ç”¨](../tools/profiler)** - æ€§èƒ½åˆ†æå·¥å…·

---

## 11. å»¶ä¼¸é˜…è¯»

### å®˜æ–¹èµ„æº

- [memo](https://react.dev/reference/react/memo) - Reactå®˜æ–¹æ–‡æ¡£
- [React Profiler](https://react.dev/reference/react/Profiler) - æ€§èƒ½åˆ†æå·¥å…·
- [Performance](https://react.dev/reference/react) - æ€§èƒ½ç›¸å…³API

### æ¨èé˜…è¯»

- [Optimizing React Performance](https://kentcdodds.com/blog/application-state-management-with-react) - æ€§èƒ½ä¼˜åŒ–æŒ‡å—
- [When to useMemo and useCallback](https://kentcdodds.com/blog/) - ä¼˜åŒ–ç­–ç•¥
- [React.memo vs useMemo](https://blog.logrocket.com/) - ä¼˜åŒ–æŠ€æœ¯å¯¹æ¯”

### ç›¸å…³è¯é¢˜

- [useCallbackå’ŒuseMemo](../hooks/advanced/useCallback) - Hookæ€§èƒ½ä¼˜åŒ–
- [çŠ¶æ€ç®¡ç†](../state-management/) - çŠ¶æ€æ›´æ–°ä¼˜åŒ–
- [ç»„ä»¶æ¨¡å¼](../patterns/) - æ€§èƒ½å‹å¥½çš„ç»„ä»¶è®¾è®¡

---

[â† ä¸Šä¸€ç« ï¼šçŠ¶æ€ç®¡ç†æ€»ç»“](../state-management/) | [ä¸‹ä¸€ç« ï¼šè™šæ‹ŸåŒ–æŠ€æœ¯ â†’](../virtualization)
