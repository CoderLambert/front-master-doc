# è™šæ‹ŸåŒ–æŠ€æœ¯ - å¤§æ•°æ®åˆ—è¡¨æ€§èƒ½ä¼˜åŒ–

import { Tabs, TabItem } from '@docusaurus/theme-common';

è™šæ‹ŸåŒ–æŠ€æœ¯æ˜¯å¤„ç†å¤§æ•°æ®åˆ—è¡¨å’Œå¤æ‚DOMç»“æ„çš„å¼ºå¤§æ€§èƒ½ä¼˜åŒ–æ‰‹æ®µã€‚é€šè¿‡åªæ¸²æŸ“è§†çª—å†…çš„å†…å®¹ï¼Œè™šæ‹ŸåŒ–å¯ä»¥å°†åˆ—è¡¨æ¸²æŸ“æ€§èƒ½æå‡90%ä»¥ä¸Šï¼ŒåŒæ—¶å¤§å¹…å‡å°‘å†…å­˜å ç”¨ã€‚æœ¬ç« å°†æ·±å…¥æ¢è®¨è™šæ‹ŸåŒ–æŠ€æœ¯çš„åŸç†ã€å®ç°æ–¹å¼å’Œå®é™…åº”ç”¨ã€‚

## æœ¬ç« å­¦ä¹ ç›®æ ‡

- ç†è§£è™šæ‹ŸåŒ–æŠ€æœ¯çš„æ ¸å¿ƒåŸç†å’Œä¼˜åŠ¿
- æŒæ¡è™šæ‹Ÿæ»šåŠ¨çš„å®ç°æœºåˆ¶
- å­¦ä¼šä½¿ç”¨Reactå®ç°è™šæ‹ŸåŒ–åˆ—è¡¨
- ç†è§£å›ºå®šé«˜åº¦å’ŒåŠ¨æ€é«˜åº¦è™šæ‹ŸåŒ–
- æŒæ¡è™šæ‹ŸåŒ–ä¸React.memoçš„ç»“åˆä½¿ç”¨
- å­¦ä¼šä½¿ç”¨ç¬¬ä¸‰æ–¹è™šæ‹ŸåŒ–åº“
- ç†è§£è™šæ‹ŸåŒ–çš„é€‚ç”¨åœºæ™¯å’Œé™åˆ¶
- æŒæ¡è™šæ‹ŸåŒ–çš„æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- å­¦ä¼šåœ¨çœŸå®é¡¹ç›®ä¸­åº”ç”¨è™šæ‹ŸåŒ–
- æŒæ¡è™šæ‹ŸåŒ–çš„è°ƒè¯•å’Œç›‘æ§æ–¹æ³•

---

## 1. è™šæ‹ŸåŒ–æŠ€æœ¯æ¦‚è¿°

è™šæ‹ŸåŒ–ï¼ˆVirtualizationï¼‰æ˜¯ä¸€ç§é€šè¿‡åªæ¸²æŸ“å¯è§åŒºåŸŸå†…å®¹æ¥ä¼˜åŒ–å¤§é‡æ•°æ®æ¸²æŸ“çš„æŠ€æœ¯ã€‚

<Box style={{ padding: '20px', background: '#e3f2fd', borderRadius: '8px', margin: '20px 0' }}>
  <h4 style={{ margin: 0, color: '#1976d2' }}>ğŸ’¡ æ ¸å¿ƒç†å¿µ</h4>
  <p style={{ margin: '10px 0 0 0' }}>
    <strong>è§†çª—æ¸²æŸ“</strong> - åªæ¸²æŸ“å½“å‰å¯è§çš„åˆ—è¡¨é¡¹<br />
    <strong>çª—å£å›æ”¶</strong> - æ»šåŠ¨æ—¶å¤ç”¨DOMå…ƒç´ <br />
    <strong>ç´¢å¼•è®¡ç®—</strong> - åŠ¨æ€è®¡ç®—å¯è§èŒƒå›´<br />
    <strong>æ€§èƒ½é£è·ƒ</strong> - å¤„ç†ä¸‡çº§æ•°æ®ä¾ç„¶æµç•…
  </p>
</Box>

<CodeBlock>

```jsx
// ä¼ ç»Ÿåˆ—è¡¨ - æ¸²æŸ“10000ä¸ªé¡¹ç›®
function BadList({ items }) {
  return (
    <div>
      {items.map((item, index) => (
        <ListItem key={item.id} item={item} />
      ))}
      {/* æ€§èƒ½é—®é¢˜ï¼šDOMä¸­æœ‰10000ä¸ªå…ƒç´ ï¼ */}
    </div>
  );
}

// è™šæ‹ŸåŒ–åˆ—è¡¨ - åªæ¸²æŸ“å¯è§çš„10-20ä¸ªé¡¹ç›®
function VirtualizedList({ items, itemHeight = 60 }) {
  const [visibleRange, setVisibleRange] = useState({
    start: 0,
    end: 20
  });

  // æ ¹æ®æ»šåŠ¨ä½ç½®è®¡ç®—å¯è§èŒƒå›´
  const handleScroll = (e) => {
    const scrollTop = e.target.scrollTop;
    const start = Math.floor(scrollTop / itemHeight);
    const end = Math.min(start + 20, items.length);
    setVisibleRange({ start, end });
  };

  return (
    <div className="virtualized-list" onScroll={handleScroll}>
      {/* æ€»é«˜åº¦å ä½ï¼Œä¸ºæ»šåŠ¨æ¡æä¾›å®¹å™¨ */}
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        {/* åªæ¸²æŸ“å¯è§é¡¹ç›® */}
        {items.slice(visibleRange.start, visibleRange.end).map((item, index) => (
          <div
            key={item.id}
            style={{
              position: 'absolute',
              top: (visibleRange.start + index) * itemHeight,
              height: itemHeight
            }}
          >
            <ListItem item={item} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

</CodeBlock>

### 1.1 è™šæ‹ŸåŒ–çš„å·¥ä½œåŸç†

<Grid>

<div>
  <h4>ğŸ“Š æ€§èƒ½å¯¹æ¯”</h4>
  <ul>
    <li><strong>ä¼ ç»Ÿåˆ—è¡¨</strong>ï¼š10000ä¸ªDOMèŠ‚ç‚¹</li>
    <li><strong>è™šæ‹ŸåŒ–åˆ—è¡¨</strong>ï¼š~20ä¸ªDOMèŠ‚ç‚¹</li>
    <li><strong>æ€§èƒ½æå‡</strong>ï¼š99.8% DOMå‡å°‘</li>
    <li><strong>å†…å­˜èŠ‚çœ</strong>ï¼š90%+ å†…å­˜ä¼˜åŒ–</li>
    <li><strong>æ¸²æŸ“æ—¶é—´</strong>ï¼šæ¯«ç§’çº§å“åº”</li>
  </ul>
</div>

<div>
  <h4>âš™ï¸ æ ¸å¿ƒæœºåˆ¶</h4>
  <ul>
    <li>è®¡ç®—å¯è§åŒºåŸŸç´¢å¼•</li>
    <li>åŠ¨æ€åˆ›å»º/å›æ”¶å…ƒç´ </li>
    <li>ç»å¯¹å®šä½ä¼˜åŒ–å¸ƒå±€</li>
    <li>æ»šåŠ¨äº‹ä»¶ç›‘å¬</li>
    <li>é˜²æŠ–ä¼˜åŒ–æ€§èƒ½</li>
  </ul>
</div>

</Grid>

<CodeBlock>

```jsx
// è™šæ‹ŸåŒ–åŸç†è¯¦ç»†è§£æ
function VirtualizedList({ items, itemHeight = 60, visibleCount = 10 }) {
  const containerRef = useRef(null);
  const [scrollTop, setScrollTop] = useState(0);

  // 1. è®¡ç®—å¯è§èŒƒå›´
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(startIndex + visibleCount, items.length);
  const visibleItems = items.slice(startIndex, endIndex);

  // 2. è®¡ç®—æ€»é«˜åº¦ï¼ˆä¸ºæ»šåŠ¨æ¡æä¾›å®¹å™¨ï¼‰
  const totalHeight = items.length * itemHeight;

  // 3. æ¸²æŸ“åç§»é‡
  const offsetY = startIndex * itemHeight;

  return (
    <div
      ref={containerRef}
      style={{ height: '400px', overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        {visibleItems.map((item, index) => {
          const actualIndex = startIndex + index;
          return (
            <div
              key={item.id}
              style={{
                position: 'absolute',
                top: actualIndex * itemHeight,
                left: 0,
                right: 0,
                height: itemHeight
              }}
            >
              <ListItem item={item} />
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

</CodeBlock>

### 1.2 è™šæ‹ŸåŒ–çš„ä¼˜åŠ¿ä¸é™åˆ¶

<Grid>

<div>
  <h4>âœ… ä¼˜åŠ¿</h4>
  <ul>
    <li>å¤§å¹…å‡å°‘DOMèŠ‚ç‚¹</li>
    <li>æ˜¾è‘—æå‡æ»šåŠ¨æ€§èƒ½</li>
    <li>é™ä½å†…å­˜å ç”¨</li>
    <li>æå‡é¦–å±æ¸²æŸ“é€Ÿåº¦</li>
    <li>æ”¯æŒä¸‡çº§æ•°æ®åˆ—è¡¨</li>
  </ul>
</div>

<div>
  <h4>âš ï¸ é™åˆ¶</h4>
  <ul>
    <li>å¢åŠ ä»£ç å¤æ‚åº¦</li>
    <li>éœ€è¦å›ºå®šæˆ–å¯é¢„æµ‹çš„é«˜åº¦</li>
    <li>åŠ¨æ€é«˜åº¦å®ç°å¤æ‚</li>
    <li>SEOéœ€è¦ç‰¹æ®Šå¤„ç†</li>
    <li>å­¦ä¹ æ›²çº¿è¾ƒé™¡</li>
  </ul>
</div>

</Grid>

<CodeBlock>

```jsx
// é€‚ç”¨åœºæ™¯åˆ¤æ–­
const shouldUseVirtualization = {
  // é€‚åˆè™šæ‹ŸåŒ–çš„åœºæ™¯
  goodCases: [
    'é•¿åˆ—è¡¨ï¼ˆ>100é¡¹ï¼‰',
    'èŠå¤©è®°å½•',
    'é‚®ä»¶åˆ—è¡¨',
    'æœç´¢ç»“æœ',
    'æ•°æ®è¡¨æ ¼',
    'æ—¶é—´çº¿ç»„ä»¶'
  ],

  // ä¸é€‚åˆçš„åœºæ™¯
  badCases: [
    'çŸ­åˆ—è¡¨ï¼ˆ<50é¡¹ï¼‰',
    'å›ºå®šå°‘é‡å†…å®¹',
    'éœ€è¦å®Œæ•´DOMçš„æ“ä½œ',
    'é«˜åº¦åŠ¨æ€å˜åŒ–',
    'SEOå…³é”®å†…å®¹',
    'å¤æ‚äº¤äº’å¸ƒå±€'
  ]
};

// å†³ç­–ç¤ºä¾‹
function shouldVirtualize(items, hasDynamicHeight) {
  if (items.length < 50) return false; // çŸ­åˆ—è¡¨ä¸è™šæ‹ŸåŒ–
  if (hasDynamicHeight) return false; // åŠ¨æ€é«˜åº¦éœ€è¦ç‰¹æ®Šå¤„ç†
  return true; // é•¿åˆ—è¡¨ä¸”å›ºå®šé«˜åº¦é€‚åˆè™šæ‹ŸåŒ–
}
```

</CodeBlock>

---

## 2. åŸºç¡€è™šæ‹ŸåŒ–å®ç°

### 2.1 å›ºå®šé«˜åº¦è™šæ‹ŸåŒ–

<CodeBlock>

```jsx
// åŸºç¡€å›ºå®šé«˜åº¦è™šæ‹ŸåŒ–åˆ—è¡¨
function FixedHeightVirtualList({ items, height = 400, itemHeight = 60 }) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef(null);

  // è®¡ç®—å¯è§èŒƒå›´
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    startIndex + Math.ceil(height / itemHeight) + 1,
    items.length
  );

  // é¢„æ¸²æŸ“ç¼“å†²åŒº
  const bufferSize = 5;
  const bufferStart = Math.max(0, startIndex - bufferSize);
  const bufferEnd = Math.min(items.length, endIndex + bufferSize);

  // å¯è§é¡¹
  const visibleItems = items.slice(bufferStart, bufferEnd);
  const offsetY = bufferStart * itemHeight;

  return (
    <div
      ref={containerRef}
      style={{ height, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ position: 'relative', height: items.length * itemHeight }}>
        {visibleItems.map((item, index) => {
          const itemIndex = bufferStart + index;
          return (
            <div
              key={item.id}
              style={{
                position: 'absolute',
                top: itemIndex * itemHeight,
                left: 0,
                right: 0,
                height: itemHeight
              }}
            >
              <ListItem item={item} index={itemIndex} />
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

</CodeBlock>

### 2.2 åŠ¨æ€é«˜åº¦è™šæ‹ŸåŒ–

<CodeBlock>

```jsx
// åŠ¨æ€é«˜åº¦è™šæ‹ŸåŒ– - ä½¿ç”¨è‡ªåŠ¨æµ‹é‡
function DynamicHeightVirtualList({ items, height = 400 }) {
  const [scrollTop, setScrollTop] = useState(0);
  const [itemHeights, setItemHeights] = useState({});
  const containerRef = useRef(null);

  // è®¡ç®—æ¯ä¸ªé¡¹ç›®çš„ç´¯ç§¯é«˜åº¦
  const calculateItemPositions = () => {
    const positions = [];
    let cumulativeHeight = 0;

    for (let i = 0; i < items.length; i++) {
      const itemHeight = itemHeights[i] || 60; // é»˜è®¤é«˜åº¦
      positions.push({
        index: i,
        top: cumulativeHeight,
        height: itemHeight,
        bottom: cumulativeHeight + itemHeight
      });
      cumulativeHeight += itemHeight;
    }

    return { positions, totalHeight: cumulativeHeight };
  };

  const { positions, totalHeight } = calculateItemPositions();

  // æ‰¾åˆ°å¯è§èŒƒå›´
  const findVisibleRange = () => {
    const viewportBottom = scrollTop + height;
    const visiblePositions = positions.filter(
      pos => pos.top < viewportBottom && pos.bottom > scrollTop
    );

    return {
      start: Math.max(0, visiblePositions[0]?.index || 0 - 5),
      end: Math.min(
        items.length,
        visiblePositions[visiblePositions.length - 1]?.index || 0 + 6
      )
    };
  };

  const { start, end } = findVisibleRange();
  const visibleItems = items.slice(start, end);

  // æµ‹é‡é¡¹ç›®é«˜åº¦
  const handleItemMeasure = (index, element) => {
    if (element) {
      const elementHeight = element.offsetHeight;
      setItemHeights(prev => ({
        ...prev,
        [index]: elementHeight
      }));
    }
  };

  return (
    <div
      ref={containerRef}
      style={{ height, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ position: 'relative', height: totalHeight }}>
        {visibleItems.map((item, index) => {
          const actualIndex = start + index;
          const position = positions[actualIndex];

          if (!position) return null;

          return (
            <div
              key={item.id}
              style={{
                position: 'absolute',
                top: position.top,
                left: 0,
                right: 0
              }}
            >
              <ListItem
                item={item}
                index={actualIndex}
                onMeasure={(height) => handleItemMeasure(actualIndex, height)}
              />
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

</CodeBlock>

### 2.3 çª—å£å›æ”¶æœºåˆ¶

<CodeBlock>

```jsx
// é«˜æ•ˆçš„çª—å£å›æ”¶æœºåˆ¶
class VirtualListEngine {
  constructor({ itemHeight, bufferSize = 5 }) {
    this.itemHeight = itemHeight;
    this.bufferSize = bufferSize;
    this.items = [];
    this.itemCount = 0;
    this.scrollTop = 0;
    this.containerHeight = 0;
  }

  // è®¡ç®—å¯è§èŒƒå›´
  getVisibleRange() {
    const startIndex = Math.floor(this.scrollTop / this.itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(this.containerHeight / this.itemHeight) + 1,
      this.itemCount
    );

    // æ·»åŠ ç¼“å†²åŒº
    const bufferStart = Math.max(0, startIndex - this.bufferSize);
    const bufferEnd = Math.min(this.itemCount, endIndex + this.bufferSize);

    return {
      start: bufferStart,
      end: bufferEnd,
      itemsInView: endIndex - startIndex
    };
  }

  // æ¸²æŸ“ä¼˜åŒ–
  shouldRender(index) {
    const { start, end } = this.getVisibleRange();
    return index >= start && index < end;
  }

  // æ›´æ–°æ»šåŠ¨ä½ç½®
  updateScroll(scrollTop) {
    this.scrollTop = scrollTop;
  }

  // è®¾ç½®å®¹å™¨å°ºå¯¸
  setDimensions({ containerHeight, itemCount }) {
    this.containerHeight = containerHeight;
    this.itemCount = itemCount;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
function OptimizedVirtualList({ items, itemHeight = 60 }) {
  const [scrollTop, setScrollTop] = useState(0);
  const [engine] = useState(() => new VirtualListEngine({ itemHeight }));

  useEffect(() => {
    engine.setDimensions({
      containerHeight: 400,
      itemCount: items.length
    });
  }, [items.length]);

  useEffect(() => {
    engine.updateScroll(scrollTop);
  }, [scrollTop]);

  const { start, end } = engine.getVisibleRange();
  const visibleItems = items.slice(start, end);

  return (
    <div
      style={{ height: 400, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ position: 'relative', height: items.length * itemHeight }}>
        {visibleItems.map((item, index) => {
          const actualIndex = start + index;
          return (
            <div
              key={item.id}
              style={{
                position: 'absolute',
                top: actualIndex * itemHeight,
                left: 0,
                right: 0,
                height: itemHeight
              }}
            >
              <ListItem item={item} index={actualIndex} />
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

</CodeBlock>

---

## 3. é«˜çº§è™šæ‹ŸåŒ–æ¨¡å¼

### 3.1 ç½‘æ ¼è™šæ‹ŸåŒ–

<CodeBlock>

```jsx
// äºŒç»´ç½‘æ ¼è™šæ‹ŸåŒ–
function VirtualizedGrid({
  items,
  columns = 4,
  itemWidth = 200,
  itemHeight = 200,
  gap = 16
}) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef(null);

  // è®¡ç®—åˆ—æ•°å’Œè¡Œé«˜
  const columnCount = columns;
  const rowHeight = itemHeight + gap;

  // è®¡ç®—å¯è§è¡Œ
  const startRow = Math.floor(scrollTop / rowHeight);
  const endRow = Math.min(
    startRow + Math.ceil(400 / rowHeight) + 1,
    Math.ceil(items.length / columnCount)
  );

  // è®¡ç®—å¯è§é¡¹ç›®
  const startIndex = startRow * columnCount;
  const endIndex = Math.min(endRow * columnCount, items.length);

  const visibleItems = items.slice(startIndex, endIndex);

  return (
    <div
      ref={containerRef}
      style={{ height: 400, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div
        style={{
          position: 'relative',
          width: '100%',
          padding: gap / 2
        }}
      >
        {visibleItems.map((item, index) => {
          const actualIndex = startIndex + index;
          const row = Math.floor(actualIndex / columnCount);
          const col = actualIndex % columnCount;

          return (
            <div
              key={item.id}
              style={{
                position: 'absolute',
                top: row * rowHeight,
                left: col * (itemWidth + gap),
                width: itemWidth,
                height: itemHeight
              }}
            >
              <GridItem item={item} />
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

</CodeBlock>

### 3.2 åˆ†ç»„è™šæ‹ŸåŒ–

<CodeBlock>

```jsx
// å¸¦åˆ†ç»„çš„è™šæ‹ŸåŒ–åˆ—è¡¨
function GroupedVirtualList({ groups, groupHeight = 40, itemHeight = 60 }) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef(null);

  // è®¡ç®—æ‰€æœ‰é¡¹ç›®çš„ä½ç½®
  const calculatePositions = () => {
    let currentY = 0;
    const positions = [];

    groups.forEach((group) => {
      // è®°å½•åˆ†ç»„ä½ç½®
      positions.push({
        type: 'group',
        index: group.id,
        top: currentY,
        height: groupHeight,
        data: group
      });
      currentY += groupHeight;

      // è®°å½•é¡¹ç›®ä½ç½®
      group.items.forEach((item) => {
        positions.push({
          type: 'item',
          index: item.id,
          top: currentY,
          height: itemHeight,
          data: item
        });
        currentY += itemHeight;
      });
    });

    return { positions, totalHeight: currentY };
  };

  const { positions, totalHeight } = calculatePositions();

  // æ‰¾åˆ°å¯è§èŒƒå›´
  const viewportBottom = scrollTop + 400;
  const visiblePositions = positions.filter(
    pos => pos.top < viewportBottom && pos.top + pos.height > scrollTop
  );

  return (
    <div
      ref={containerRef}
      style={{ height: 400, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ position: 'relative', height: totalHeight }}>
        {visiblePositions.map((pos) => {
          if (pos.type === 'group') {
            return (
              <div
                key={`group-${pos.index}`}
                style={{
                  position: 'absolute',
                  top: pos.top,
                  left: 0,
                  right: 0,
                  height: pos.height,
                  backgroundColor: '#f0f0f0',
                  fontWeight: 'bold',
                  padding: '8px 16px',
                  borderBottom: '1px solid #ddd'
                }}
              >
                {pos.data.title} ({pos.data.items.length} items)
              </div>
            );
          } else {
            return (
              <div
                key={`item-${pos.index}`}
                style={{
                  position: 'absolute',
                  top: pos.top,
                  left: 0,
                  right: 0,
                  height: pos.height,
                  padding: '0 16px'
                }}
              >
                <ListItem item={pos.data} />
              </div>
            );
          }
        })}
      </div>
    </div>
  );
}
```

</CodeBlock>

### 3.3 æ‡’åŠ è½½è™šæ‹ŸåŒ–

<CodeBlock>

```jsx
// æ‡’åŠ è½½æ•°æ®çš„è™šæ‹ŸåŒ–åˆ—è¡¨
function LazyVirtualList({ fetchMore, hasMore, itemHeight = 60 }) {
  const [items, setItems] = useState([]);
  const [scrollTop, setScrollTop] = useState(0);
  const [loading, setLoading] = useState(false);
  const containerRef = useRef(null);

  // æ»šåŠ¨åˆ°åº•éƒ¨è‡ªåŠ¨åŠ è½½
  useEffect(() => {
    const { start, end } = getVisibleRange();
    if (end >= items.length - 20 && hasMore && !loading) {
      loadMore();
    }
  }, [scrollTop, items.length, hasMore, loading]);

  const loadMore = async () => {
    setLoading(true);
    try {
      const newItems = await fetchMore(items.length);
      setItems(prev => [...prev, ...newItems]);
    } finally {
      setLoading(false);
    }
  };

  const getVisibleRange = () => {
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(400 / itemHeight) + 1,
      items.length
    );
    return { start: startIndex, end: endIndex };
  };

  const { start, end } = getVisibleRange();
  const visibleItems = items.slice(start, end);

  return (
    <div
      ref={containerRef}
      style={{ height: 400, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ position: 'relative', height: items.length * itemHeight }}>
        {visibleItems.map((item, index) => {
          const actualIndex = start + index;
          return (
            <div
              key={item.id}
              style={{
                position: 'absolute',
                top: actualIndex * itemHeight,
                left: 0,
                right: 0,
                height: itemHeight
              }}
            >
              <ListItem item={item} />
            </div>
          );
        })}

        {loading && (
          <div
            style={{
              position: 'absolute',
              top: items.length * itemHeight,
              left: 0,
              right: 0,
              height: 60,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center'
            }}
          >
            Loading more...
          </div>
        )}
      </div>
    </div>
  );
}
```

</CodeBlock>

---

## 4. ç¬¬ä¸‰æ–¹åº“ä½¿ç”¨

### 4.1 react-window

<CodeBlock>

```jsx
// ä½¿ç”¨react-windowå®ç°è™šæ‹ŸåŒ–
import { FixedSizeList as List } from 'react-window';
import { VariableSizeList } from 'react-window';

// åŸºç¡€ç”¨æ³• - å›ºå®šé«˜åº¦
function FixedHeightList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      <ListItem item={items[index]} />
    </div>
  );

  return (
    <List
      height={400}        // å®¹å™¨é«˜åº¦
      itemCount={items.length}  // é¡¹ç›®æ•°é‡
      itemSize={60}       // æ¯ä¸ªé¡¹ç›®é«˜åº¦
      width="100%"        // å®¹å™¨å®½åº¦
    >
      {Row}
    </List>
  );
}

// é«˜çº§ç”¨æ³• - åŠ¨æ€é«˜åº¦
function DynamicHeightList({ items }) {
  const getItemSize = (index) => {
    return items[index].height || 60;
  };

  const Row = ({ index, style }) => (
    <div style={style}>
      <ListItem item={items[index]} />
    </div>
  );

  return (
    <VariableSizeList
      height={400}
      itemCount={items.length}
      itemSize={getItemSize}
      width="100%"
    >
      {Row}
    </VariableSizeList>
  );
}
```

</CodeBlock>

### 4.2 react-virtualized

<CodeBlock>

```jsx
// ä½¿ç”¨react-virtualized - åŠŸèƒ½æ›´ä¸°å¯Œ
import {
  List,
  Masonry,
  CellMeasurer,
  CellMeasurerCache
} from 'react-virtualized';
import 'react-virtualized/styles.css';

// åŸºç¡€è™šæ‹ŸåŒ–åˆ—è¡¨
function VirtualizedList({ items }) {
  const renderRow = ({ index, key, style }) => (
    <div key={key} style={style}>
      <ListItem item={items[index]} />
    </div>
  );

  return (
    <List
      width={800}
      height={400}
      rowCount={items.length}
      rowHeight={60}
      rowRenderer={renderRow}
    />
  );
}

// ç€‘å¸ƒæµå¸ƒå±€
function MasonryGrid({ items, columnWidth = 200, gutterSize = 16 }) {
  const cellRenderer = ({ index, key, parent, style }) => {
    const item = items[index];
    return (
      <CellMeasurer
        cache={cache}
        columnIndex={0}
        key={key}
        rowIndex={index}
        parent={parent}
      >
        <div style={style}>
          <MasonryItem item={item} />
        </div>
      </CellMeasurer>
    );
  };

  return (
    <Masonry
      autoHeight
      cellCount={items.length}
      cellMeasurerCache={cache}
      cellRenderer={cellRenderer}
      height={600}
      gutterSize={gutterSize}
      columnWidth={columnWidth}
    />
  );
}
```

</CodeBlock>

### 4.3 @tanstack/react-virtual

<CodeBlock>

```jsx
// ä½¿ç”¨@tanstack/react-virtual - ç°ä»£è™šæ‹ŸåŒ–åº“
import { useVirtualizer } from '@tanstack/react-virtual';

// å‚ç›´è™šæ‹ŸåŒ–
function VerticalVirtualList({ items }) {
  const parentRef = useRef(null);
  const virtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 60,
    overscan: 10
  });

  return (
    <div
      ref={parentRef}
      style={{
        height: `400px`,
        overflow: 'auto'
      }}
    >
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          width: '100%',
          position: 'relative'
        }}
      >
        {virtualizer.getVirtualItems().map((virtualItem) => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${virtualItem.size}px`,
              transform: `translateY(${virtualItem.start}px)`
            }}
          >
            <ListItem item={items[virtualItem.index]} />
          </div>
        ))}
      </div>
    </div>
  );
}

// æ°´å¹³è™šæ‹ŸåŒ–
function HorizontalVirtualList({ items }) {
  const parentRef = useRef(null);
  const virtualizer = useVirtualizer({
    count: items.length,
    horizontal: true,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 200,
    overscan: 5
  });

  return (
    <div
      ref={parentRef}
      style={{
        height: '400px',
        overflow: 'auto'
      }}
    >
      <div
        style={{
          width: `${virtualizer.getTotalSize()}px`,
          height: '100%',
          position: 'relative'
        }}
      >
        {virtualizer.getVirtualItems().map((virtualItem) => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: `${virtualItem.size}px`,
              height: '100%',
              transform: `translateX(${virtualItem.start}px)`
            }}
          >
            <HorizontalItem item={items[virtualItem.index]} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

</CodeBlock>

---

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 èŠå¤©è®°å½•åˆ—è¡¨

<CodeBlock>

```jsx
// èŠå¤©è®°å½•è™šæ‹ŸåŒ–
function ChatVirtualList({ messages }) {
  const containerRef = useRef(null);
  const [scrollTop, setScrollTop] = useState(0);

  // ä¸åŒç±»å‹æ¶ˆæ¯æœ‰ä¸åŒé«˜åº¦
  const getMessageHeight = (message) => {
    if (message.type === 'image') return 200;
    if (message.type === 'file') return 80;
    if (message.content.length > 50) return 100;
    return 60;
  };

  // é¢„è®¡ç®—æ‰€æœ‰æ¶ˆæ¯ä½ç½®
  const calculatePositions = () => {
    let currentY = 0;
    return messages.map((message) => {
      const height = getMessageHeight(message);
      const position = { top: currentY, height };
      currentY += height;
      return position;
    });
  };

  const positions = calculatePositions();
  const totalHeight = positions[positions.length - 1]?.top + positions[positions.length - 1]?.height || 0;

  // æ‰¾åˆ°å¯è§æ¶ˆæ¯
  const getVisibleMessages = () => {
    const viewportBottom = scrollTop + 400;
    return positions
      .map((pos, index) => ({ ...pos, message: messages[index] }))
      .filter(pos => pos.top < viewportBottom && pos.top + pos.height > scrollTop);
  };

  const visibleMessages = getVisibleMessages();

  return (
    <div
      ref={containerRef}
      style={{ height: 400, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ position: 'relative', height: totalHeight }}>
        {visibleMessages.map((item) => (
          <div
            key={item.message.id}
            style={{
              position: 'absolute',
              top: item.top,
              left: 0,
              right: 0,
              height: item.height,
              padding: '8px 16px'
            }}
          >
            <MessageBubble message={item.message} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

</CodeBlock>

### 5.2 æ•°æ®è¡¨æ ¼è™šæ‹ŸåŒ–

<CodeBlock>

```jsx
// å¤§æ•°æ®è¡¨æ ¼è™šæ‹ŸåŒ–
function VirtualizedTable({ data, columns }) {
  const containerRef = useRef(null);
  const [scrollTop, setScrollTop] = useState(0);
  const rowHeight = 50;

  // è®¡ç®—å¯è§è¡Œ
  const startRow = Math.floor(scrollTop / rowHeight);
  const endRow = Math.min(
    startRow + Math.ceil(400 / rowHeight) + 1,
    data.length
  );

  // ç¼“å†²åŒº
  const bufferSize = 5;
  const bufferStart = Math.max(0, startRow - bufferSize);
  const bufferEnd = Math.min(data.length, endRow + bufferSize);

  const visibleRows = data.slice(bufferStart, bufferEnd);

  return (
    <div
      ref={containerRef}
      style={{ height: 400, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ position: 'relative' }}>
        {/* è¡¨å¤´ */}
        <div
          style={{
            position: 'sticky',
            top: 0,
            backgroundColor: '#f5f5f5',
            display: 'flex',
            borderBottom: '1px solid #ddd',
            fontWeight: 'bold',
            zIndex: 1
          }}
        >
          {columns.map((col) => (
            <div
              key={col.key}
              style={{
                flex: col.flex || 1,
                padding: '12px 8px',
                borderRight: '1px solid #ddd'
              }}
            >
              {col.title}
            </div>
          ))}
        </div>

        {/* è™šæ‹ŸåŒ–è¡Œ */}
        <div style={{ position: 'relative', height: data.length * rowHeight }}>
          {visibleRows.map((row, index) => {
            const actualIndex = bufferStart + index;
            return (
              <div
                key={row.id}
                style={{
                  position: 'absolute',
                  top: actualIndex * rowHeight,
                  left: 0,
                  right: 0,
                  height: rowHeight,
                  display: 'flex',
                  borderBottom: '1px solid #eee',
                  alignItems: 'center'
                }}
              >
                {columns.map((col) => (
                  <div
                    key={col.key}
                    style={{
                      flex: col.flex || 1,
                      padding: '0 8px'
                    }}
                  >
                    {row[col.key]}
                  </div>
                ))}
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
}
```

</CodeBlock>

### 5.3 æ—¶é—´çº¿ç»„ä»¶

<CodeBlock>

```jsx
// æ—¶é—´çº¿è™šæ‹ŸåŒ–
function VirtualizedTimeline({ events }) {
  const containerRef = useRef(null);
  const [scrollTop, setScrollTop] = useState(0);
  const eventHeight = 80;

  // æ—¶é—´çº¿é¡¹ç›®å¯èƒ½è·¨å¤šè¡Œ
  const calculateEventPositions = () => {
    let currentY = 0;
    return events.map((event) => {
      const height = Math.max(
        eventHeight,
        calculateEventHeight(event)
      );
      const position = {
        top: currentY,
        height,
        event
      };
      currentY += height;
      return position;
    });
  };

  const positions = calculateEventPositions();
  const totalHeight = positions[positions.length - 1]?.top + positions[positions.length - 1]?.height || 0;

  // æ‰¾åˆ°å¯è§äº‹ä»¶
  const getVisibleEvents = () => {
    const viewportBottom = scrollTop + 400;
    return positions.filter(
      pos => pos.top < viewportBottom && pos.top + pos.height > scrollTop
    );
  };

  const visibleEvents = getVisibleEvents();

  return (
    <div
      ref={containerRef}
      style={{ height: 400, overflow: 'auto', position: 'relative' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ position: 'relative', height: totalHeight }}>
        {/* æ—¶é—´çº¿ */}
        <div
          style={{
            position: 'absolute',
            left: '50%',
            top: 0,
            bottom: 0,
            width: 2,
            backgroundColor: '#ddd',
            transform: 'translateX(-1px)'
          }}
        />

        {visibleEvents.map((item) => (
          <div
            key={item.event.id}
            style={{
              position: 'absolute',
              top: item.top,
              left: '50%',
              width: '50%',
              padding: '0 20px',
              transform: 'translateX(-50%)'
            }}
          >
            <div
              style={{
                backgroundColor: '#f5f5f5',
                padding: '16px',
                borderRadius: '8px',
                position: 'relative'
              }}
            >
              {/* æ—¶é—´ç‚¹ */}
              <div
                style={{
                  position: 'absolute',
                  left: '-20px',
                  top: '20px',
                  width: 12,
                  height: 12,
                  backgroundColor: '#4CAF50',
                  borderRadius: '50%',
                  border: '2px solid white'
                }}
              />
              <div style={{ fontSize: '12px', color: '#666' }}>
                {item.event.date}
              </div>
              <div style={{ fontSize: '14px', fontWeight: 'bold' }}>
                {item.event.title}
              </div>
              <div style={{ fontSize: '13px', color: '#666' }}>
                {item.event.description}
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

</CodeBlock>

---

## 6. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 6.1 ç¼“å†²åŒºç®¡ç†

<CodeBlock>

```jsx
// æ™ºèƒ½ç¼“å†²åŒºç®¡ç†
function SmartBufferVirtualList({ items, itemHeight = 60 }) {
  const [scrollTop, setScrollTop] = useState(0);
  const [bufferSize, setBufferSize] = useState(5);
  const containerRef = useRef(null);

  // æ ¹æ®æ»šåŠ¨é€Ÿåº¦åŠ¨æ€è°ƒæ•´ç¼“å†²åŒº
  useEffect(() => {
    const handleScroll = (e) => {
      const currentScrollTop = e.target.scrollTop;
      const scrollDelta = Math.abs(currentScrollTop - scrollTop);

      // å¿«é€Ÿæ»šåŠ¨æ—¶å¢åŠ ç¼“å†²åŒº
      if (scrollDelta > 100) {
        setBufferSize(10);
      } else if (scrollDelta > 50) {
        setBufferSize(7);
      } else {
        setBufferSize(5);
      }
    };

    const element = containerRef.current;
    if (element) {
      element.addEventListener('scroll', handleScroll);
      return () => element.removeEventListener('scroll', handleScroll);
    }
  }, [scrollTop]);

  // è®¡ç®—å¯è§èŒƒå›´
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    startIndex + Math.ceil(400 / itemHeight) + 1,
    items.length
  );

  // åº”ç”¨ç¼“å†²åŒº
  const bufferStart = Math.max(0, startIndex - bufferSize);
  const bufferEnd = Math.min(items.length, endIndex + bufferSize);

  const visibleItems = items.slice(bufferStart, bufferEnd);

  return (
    <div
      ref={containerRef}
      style={{ height: 400, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ position: 'relative', height: items.length * itemHeight }}>
        {visibleItems.map((item, index) => {
          const actualIndex = bufferStart + index;
          return (
            <div
              key={item.id}
              style={{
                position: 'absolute',
                top: actualIndex * itemHeight,
                left: 0,
                right: 0,
                height: itemHeight
              }}
            >
              <ListItem item={item} index={actualIndex} />
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

</CodeBlock>

### 6.2 é˜²æŠ–ä¼˜åŒ–

<CodeBlock>

```jsx
// ä½¿ç”¨é˜²æŠ–ä¼˜åŒ–æ»šåŠ¨æ€§èƒ½
function DebouncedVirtualList({ items, itemHeight = 60 }) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef(null);

  // é˜²æŠ–çš„æ»šåŠ¨å¤„ç†
  const debouncedSetScrollTop = useMemo(
    () => debounce((value) => setScrollTop(value), 16),
    []
  );

  const handleScroll = (e) => {
    debouncedSetScrollTop(e.target.scrollTop);
  };

  // æ¸…ç†é˜²æŠ–å®šæ—¶å™¨
  useEffect(() => {
    return () => {
      debouncedSetScrollTop.cancel();
    };
  }, [debouncedSetScrollTop]);

  // è®¡ç®—å¯è§èŒƒå›´
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    startIndex + Math.ceil(400 / itemHeight) + 1,
    items.length
  );

  const visibleItems = items.slice(startIndex, endIndex);

  return (
    <div
      ref={containerRef}
      style={{ height: 400, overflow: 'auto' }}
      onScroll={handleScroll}
    >
      <div style={{ position: 'relative', height: items.length * itemHeight }}>
        {visibleItems.map((item, index) => {
          const actualIndex = startIndex + index;
          return (
            <div
              key={item.id}
              style={{
                position: 'absolute',
                top: actualIndex * itemHeight,
                left: 0,
                right: 0,
                height: itemHeight
              }}
            >
              <ListItem item={item} index={actualIndex} />
            </div>
          );
        })}
      </div>
    </div>
  );
}

// é˜²æŠ–å‡½æ•°
function debounce(func, wait) {
  let timeout;
  const debouncedFunction = function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };

  debouncedFunction.cancel = () => {
    clearTimeout(timeout);
  };

  return debouncedFunction;
}
```

</CodeBlock>

### 6.3 React.memoé›†æˆ

<CodeBlock>

```jsx
// ä¸React.memoç»“åˆä¼˜åŒ–
const VirtualizedListItem = React.memo(({ item, index, style }) => (
  <div style={style}>
    <ListItem item={item} index={index} />
  </div>
));

function MemoizedVirtualList({ items, itemHeight = 60 }) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef(null);

  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    startIndex + Math.ceil(400 / itemHeight) + 1,
    items.length
  );

  const visibleItems = items.slice(startIndex, endIndex);

  return (
    <div
      ref={containerRef}
      style={{ height: 400, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.target.scrollTop)}
    >
      <div style={{ position: 'relative', height: items.length * itemHeight }}>
        {visibleItems.map((item, index) => {
          const actualIndex = startIndex + index;
          return (
            <VirtualizedListItem
              key={item.id}
              item={item}
              index={actualIndex}
              style={{
                position: 'absolute',
                top: actualIndex * itemHeight,
                left: 0,
                right: 0,
                height: itemHeight
              }}
            />
          );
        })}
      </div>
    </div>
  );
}
```

</CodeBlock>

---

## 7. è°ƒè¯•ä¸ç›‘æ§

### 7.1 æ€§èƒ½ç›‘æ§

<CodeBlock>

```jsx
// è™šæ‹ŸåŒ–æ€§èƒ½ç›‘æ§
function PerformanceMonitoredVirtualList({ items }) {
  const containerRef = useRef(null);
  const [metrics, setMetrics] = useState({
    renderTime: 0,
    visibleItems: 0,
    totalItems: 0,
    scrollEvents: 0
  });

  const startTimeRef = useRef(performance.now());

  const measureRender = useCallback(() => {
    const endTime = performance.now();
    const renderTime = endTime - startTimeRef.current;

    setMetrics(prev => ({
      ...prev,
      renderTime
    }));

    startTimeRef.current = performance.now();
  }, []);

  useEffect(() => {
    measureRender();
  }, [measureRender]);

  const handleScroll = (e) => {
    setMetrics(prev => ({
      ...prev,
      scrollEvents: prev.scrollEvents + 1
    }));
  };

  // ç›‘æ§æ•°æ®
  return (
    <div>
      <div style={{ padding: '8px', backgroundColor: '#f0f0f0' }}>
        <strong>æ€§èƒ½ç›‘æ§</strong>
        <div>æ¸²æŸ“æ—¶é—´: {metrics.renderTime.toFixed(2)}ms</div>
        <div>å¯è§é¡¹ç›®: {metrics.visibleItems}</div>
        <div>æ€»é¡¹ç›®: {metrics.totalItems}</div>
        <div>æ»šåŠ¨äº‹ä»¶: {metrics.scrollEvents}</div>
      </div>

      <div
        ref={containerRef}
        style={{ height: 400, overflow: 'auto' }}
        onScroll={handleScroll}
      >
        {/* è™šæ‹ŸåŒ–å†…å®¹ */}
      </div>
    </div>
  );
}
```

</CodeBlock>

### 7.2 å¯è§†åŒ–è°ƒè¯•

<CodeBlock>

```jsx
// è™šæ‹ŸåŒ–å¯è§†åŒ–è°ƒè¯•
function DebugVirtualList({ items, itemHeight = 60 }) {
  const [scrollTop, setScrollTop] = useState(0);
  const [showDebug, setShowDebug] = useState(true);
  const containerRef = useRef(null);

  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(
    startIndex + Math.ceil(400 / itemHeight) + 1,
    items.length
  );

  const visibleItems = items.slice(startIndex, endIndex);

  return (
    <div style={{ position: 'relative' }}>
      {showDebug && (
        <div
          style={{
            position: 'absolute',
            top: 0,
            right: 0,
            padding: '8px',
            backgroundColor: 'rgba(0,0,0,0.7)',
            color: 'white',
            zIndex: 10,
            fontSize: '12px',
            borderRadius: '4px'
          }}
        >
          <div>å¯è§èŒƒå›´: {startIndex} - {endIndex}</div>
          <div>å¯è§æ•°é‡: {visibleItems.length}</div>
          <div>æ€»æ•°é‡: {items.length}</div>
          <div>æ»šåŠ¨ä½ç½®: {scrollTop}px</div>
        </div>
      )}

      <div
        ref={containerRef}
        style={{ height: 400, overflow: 'auto' }}
        onScroll={(e) => setScrollTop(e.target.scrollTop)}
      >
        <div style={{ position: 'relative', height: items.length * itemHeight }}>
          {/* å¯è§åŒºåŸŸæ ‡è®° */}
          <div
            style={{
              position: 'absolute',
              top: startIndex * itemHeight,
              left: 0,
              right: 0,
              height: (endIndex - startIndex) * itemHeight,
              backgroundColor: 'rgba(0, 255, 0, 0.1)',
              pointerEvents: 'none',
              zIndex: 5
            }}
          />

          {visibleItems.map((item, index) => {
            const actualIndex = startIndex + index;
            return (
              <div
                key={item.id}
                style={{
                  position: 'absolute',
                  top: actualIndex * itemHeight,
                  left: 0,
                  right: 0,
                  height: itemHeight,
                  border: '1px solid #ccc',
                  padding: '8px'
                }}
              >
                <div style={{ fontSize: '10px', color: '#999' }}>
                  Index: {actualIndex}
                </div>
                <ListItem item={item} />
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
}
```

</CodeBlock>

---

## 8. å¸¸è§é™·é˜±å’Œè§£å†³æ–¹æ¡ˆ

### é™·é˜±1ï¼šåŠ¨æ€é«˜åº¦æµ‹é‡

<ErrorBox>

```jsx
// âŒ é”™è¯¯ - åŠ¨æ€é«˜åº¦å¯¼è‡´å¸ƒå±€é—ªçƒ
function BadDynamicList({ items }) {
  const [itemHeights, setItemHeights] = useState({});
  const [scrollTop, setScrollTop] = useState(0);

  // é—®é¢˜ï¼šæ¯æ¬¡é«˜åº¦å˜åŒ–éƒ½é‡æ–°è®¡ç®—æ‰€æœ‰ä½ç½®
  const getItemPosition = (index) => {
    let position = 0;
    for (let i = 0; i < index; i++) {
      position += itemHeights[i] || 60;
    }
    return position;
  };

  // é—®é¢˜ï¼šå¯¼è‡´æ— é™å¾ªç¯
  return (
    <div onScroll={(e) => setScrollTop(e.target.scrollTop)}>
      {items.map((item, index) => (
        <div
          key={item.id}
          style={{ position: 'absolute', top: getItemPosition(index) }}
        >
          <ListItem
            item={item}
            onMeasure={(height) =>
              setItemHeights(prev => ({ ...prev, [index]: height }))
            }
          />
        </div>
      ))}
    </div>
  );
}

// âœ… æ­£ç¡® - ä½¿ç”¨æµ‹é‡ç¼“å­˜
function GoodDynamicList({ items }) {
  const [itemHeights, setItemHeights] = useState({});
  const [scrollTop, setScrollTop] = useState(0);

  // ä½¿ç”¨useMemoç¼“å­˜ä½ç½®è®¡ç®—
  const positions = useMemo(() => {
    let position = 0;
    return items.map((item, index) => {
      const height = itemHeights[index] || 60;
      const pos = { index, top: position, height };
      position += height;
      return pos;
    });
  }, [items.length, itemHeights]);

  // åªåœ¨æµ‹é‡å®Œæˆåå†æ¸²æŸ“
  return (
    <div onScroll={(e) => setScrollTop(e.target.scrollTop)}>
      {positions.map((pos) => (
        <div
          key={pos.index}
          style={{ position: 'absolute', top: pos.top }}
        >
          <ListItem
            item={items[pos.index]}
            onMeasure={(height) =>
              setItemHeights(prev => ({ ...prev, [pos.index]: height }))
            }
          />
        </div>
      ))}
    </div>
  );
}
```

</ErrorBox>

### é™·é˜±2ï¼šReact Keyé—®é¢˜

<ErrorBox>

```jsx
// âŒ é”™è¯¯ - ä½¿ç”¨ç´¢å¼•ä½œä¸ºkey
function BadKeyList({ items }) {
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 20 });

  return (
    <div>
      {items.slice(visibleRange.start, visibleRange.end).map((item, index) => (
        <div key={index}> {/* é”™è¯¯ï¼škeyåŸºäºå¯è§ç´¢å¼•ï¼Œä¸æ˜¯å®é™…é¡¹ç›®ID */}
          <ListItem item={item} />
        </div>
      ))}
    </div>
  );
}

// âœ… æ­£ç¡® - ä½¿ç”¨é¡¹ç›®IDä½œä¸ºkey
function GoodKeyList({ items }) {
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 20 });

  return (
    <div>
      {items.slice(visibleRange.start, visibleRange.end).map((item) => (
        <div key={item.id}> {/* æ­£ç¡®ï¼šä½¿ç”¨é¡¹ç›®å”¯ä¸€ID */}
          <ListItem item={item} />
        </div>
      ))}
    </div>
  );
}
```

</ErrorBox>

### é™·é˜±3ï¼šé¢‘ç¹é‡æ¸²æŸ“

<ErrorBox>

```jsx

// âŒ é”™è¯¯ - åœ¨æ¸²æŸ“å‡½æ•°ä¸­åˆ›å»ºæ–°å¯¹è±¡
function BadOptimizedList({ items }) {
  const [scrollTop, setScrollTop] = useState(0);

  // é—®é¢˜ï¼šæ¯æ¬¡æ¸²æŸ“éƒ½åˆ›å»ºæ–°å¯¹è±¡
  const visibleItems = items.slice(
    Math.floor(scrollTop / 60),
    Math.floor(scrollTop / 60) + 20
  );

  return (
    <div onScroll={(e) => setScrollTop(e.target.scrollTop)}>
      {visibleItems.map((item) => (
        <ListItem
          key={item.id}
          item={item}
          style={{ position: 'absolute', top: item.index * 60 }} // æ–°å¯¹è±¡
        />
      ))}
    </div>
  );
}

// âœ… æ­£ç¡® - ä½¿ç”¨useMemoå’ŒuseCallback
function GoodOptimizedList({ items }) {
  const [scrollTop, setScrollTop] = useState(0);

  // ç¼“å­˜è®¡ç®—ç»“æœ
  const visibleItems = useMemo(() => {
    const start = Math.floor(scrollTop / 60);
    return items.slice(start, start + 20);
  }, [scrollTop, items]);

  // ç¼“å­˜æ»šåŠ¨å¤„ç†å‡½æ•°
  const handleScroll = useCallback((e) => {
    setScrollTop(e.target.scrollTop);
  }, []);

  // ç¼“å­˜æ ·å¼å¯¹è±¡
  const itemStyle = useCallback((index) => ({
    position: 'absolute',
    top: index * 60
  }), []);

  return (
    <div onScroll={handleScroll}>
      {visibleItems.map((item) => (
        <ListItem
          key={item.id}
          item={item}
          style={itemStyle(item.index)}
        />
      ))}
    </div>
  );
}
```

</ErrorBox>

---

## 9. æœ€ä½³å®è·µ

### 9.1 ä½•æ—¶ä½¿ç”¨è™šæ‹ŸåŒ–

<BestPractices>

```jsx
// è™šæ‹ŸåŒ–å†³ç­–æŒ‡å—
const virtualizationGuidelines = {
  // å¼ºçƒˆæ¨èä½¿ç”¨è™šæ‹ŸåŒ–
  shouldUse: [
    'åˆ—è¡¨é¡¹æ•°é‡ > 100',
    'DOMèŠ‚ç‚¹æ•°é‡ > 500',
    'å†…å­˜ä½¿ç”¨ > 50MB',
    'æ»šåŠ¨å¸§ç‡ < 30fps',
    'é¦–å±åŠ è½½æ—¶é—´ > 2s'
  ],

  // å¯é€‰ä½¿ç”¨è™šæ‹ŸåŒ–
  mayUse: [
    'åˆ—è¡¨é¡¹æ•°é‡ 50-100',
    'éƒ¨åˆ†å†…å®¹é«˜åº¦å¯å˜',
    'å¤æ‚å¸ƒå±€åµŒå¥—',
    'ç§»åŠ¨ç«¯æ€§èƒ½è¦æ±‚é«˜'
  ],

  // ä¸æ¨èä½¿ç”¨è™šæ‹ŸåŒ–
  shouldNotUse: [
    'åˆ—è¡¨é¡¹æ•°é‡ < 50',
    'å†…å®¹é«˜åº¦é«˜åº¦åŠ¨æ€',
    'éœ€è¦å®Œæ•´DOMè®¿é—®',
    'SEOå…³é”®å†…å®¹',
    'ç®€å•é™æ€åˆ—è¡¨'
  ]
};

// å®é™…å†³ç­–ç¤ºä¾‹
function shouldVirtualizeData(items, hasDynamicContent) {
  const itemCount = items.length;

  // åŸºæœ¬è§„åˆ™
  if (itemCount < 50) return false;
  if (itemCount > 100) return true;

  // è€ƒè™‘åŠ¨æ€å†…å®¹
  if (hasDynamicContent && itemCount > 75) return true;

  // æ€§èƒ½æµ‹è¯•
  if (itemCount > 60) {
    const frameRate = measureScrollPerformance(items);
    return frameRate < 30; // ä½äº30fpsä½¿ç”¨è™šæ‹ŸåŒ–
  }

  return false;
}
```

</BestPractices>

### 9.2 æ€§èƒ½ä¼˜åŒ–åŸåˆ™

<BestPractices>

```jsx
// è™šæ‹ŸåŒ–æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ
const optimizationChecklist = {
  // åŸºç¡€ä¼˜åŒ–
  basic: [
    'ä½¿ç”¨å›ºå®šé«˜åº¦ï¼ˆå¦‚æœå¯èƒ½ï¼‰',
    'å®ç°æ™ºèƒ½ç¼“å†²åŒº',
    'ä½¿ç”¨é˜²æŠ–å¤„ç†æ»šåŠ¨',
    'æœ€å°åŒ–çŠ¶æ€æ›´æ–°',
    'ä½¿ç”¨React.memoåŒ…è£…åˆ—è¡¨é¡¹'
  ],

  // é«˜çº§ä¼˜åŒ–
  advanced: [
    'ä½¿ç”¨requestAnimationFrame',
    'å®ç°çª—å£å›æ”¶',
    'é¢„åŠ è½½ä¸´è¿‘å†…å®¹',
    'ä½¿ç”¨Web Workerså¤„ç†è®¡ç®—',
    'CSSç¡¬ä»¶åŠ é€Ÿ'
  ],

  // ç›‘æ§æŒ‡æ ‡
  monitoring: [
    'å¸§ç‡ç›‘æ§ï¼ˆç›®æ ‡60fpsï¼‰',
    'å†…å­˜ä½¿ç”¨ç›‘æ§',
    'æ¸²æŸ“æ—¶é—´æµ‹é‡',
    'æ»šåŠ¨äº‹ä»¶é¢‘ç‡',
    'å¯è§é¡¹ç›®æ•°é‡'
  ]
};

// æ€§èƒ½ä¼˜åŒ–å®ç°
function OptimizedVirtualList({ items }) {
  const containerRef = useRef(null);

  // 1. ä½¿ç”¨é˜²æŠ–ä¼˜åŒ–æ»šåŠ¨
  const debouncedScroll = useMemo(
    () => debounce((value) => setScrollTop(value), 16),
    []
  );

  // 2. ä½¿ç”¨React.memoä¼˜åŒ–åˆ—è¡¨é¡¹
  const MemoizedListItem = useMemo(
    () => React.memo(ListItem),
    []
  );

  // 3. ç¼“å­˜è®¡ç®—ç»“æœ
  const visibleRange = useMemo(() => {
    return {
      start: Math.floor(scrollTop / 60),
      end: Math.floor(scrollTop / 60) + 20
    };
  }, [scrollTop]);

  // 4. ä½¿ç”¨useCallbackä¼˜åŒ–å›è°ƒ
  const handleScroll = useCallback((e) => {
    debouncedScroll(e.target.scrollTop);
  }, [debouncedScroll]);

  return (
    <div ref={containerRef} onScroll={handleScroll}>
      {/* æ¸²æŸ“é€»è¾‘ */}
    </div>
  );
}
```

</BestPractices>

### 9.3 ä»£ç ç»„ç»‡

<BestPractices>

```jsx
// è™šæ‹ŸåŒ–ç»„ä»¶çš„æ–‡ä»¶ç»„ç»‡

// 1. åŸºç¡€è™šæ‹ŸåŒ– Hook
// hooks/useVirtualList.js
export function useVirtualList({
  itemCount,
  itemHeight,
  containerHeight,
  overscan = 5
}) {
  const [scrollTop, setScrollTop] = useState(0);

  const virtualItems = useMemo(() => {
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(containerHeight / itemHeight) + 1,
      itemCount
    );

    const overscanStart = Math.max(0, startIndex - overscan);
    const overscanEnd = Math.min(itemCount, endIndex + overscan);

    return {
      start: overscanStart,
      end: overscanEnd,
      items: Array.from(
        { length: overscanEnd - overscanStart },
        (_, i) => overscanStart + i
      )
    };
  }, [scrollTop, itemCount, itemHeight, containerHeight, overscan]);

  return {
    virtualItems,
    setScrollTop,
    totalSize: itemCount * itemHeight
  };
}

// 2. é€šç”¨è™šæ‹ŸåŒ–ç»„ä»¶
// components/VirtualList.jsx
function VirtualList({
  items,
  itemHeight,
  height,
  children: ItemComponent,
  ...hookOptions
}) {
  const { virtualItems, setScrollTop, totalSize } = useVirtualList({
    itemCount: items.length,
    itemHeight,
    containerHeight: height,
    ...hookOptions
  });

  return (
    <div style={{ height, overflow: 'auto' }} onScroll={(e) => setScrollTop(e.target.scrollTop)}>
      <div style={{ position: 'relative', height: totalSize }}>
        {virtualItems.items.map((index) => (
          <div
            key={items[index].id}
            style={{
              position: 'absolute',
              top: index * itemHeight,
              left: 0,
              right: 0,
              height: itemHeight
            }}
          >
            <ItemComponent item={items[index]} index={index} />
          </div>
        ))}
      </div>
    </div>
  );
}

// 3. ä¸“ç”¨ç»„ä»¶ç¤ºä¾‹
// components/UserListVirtualized.jsx
export function UserListVirtualized({ users }) {
  return (
    <VirtualList
      items={users}
      itemHeight={80}
      height={400}
    >
      {UserItem}
    </VirtualList>
  );
}
```

</BestPractices>

---

## 10. å®è·µç»ƒä¹ 

### ç»ƒä¹ 1ï¼šå®ç°åŸºç¡€è™šæ‹ŸåŒ–åˆ—è¡¨

<Expandable title="ç‚¹å‡»æŸ¥çœ‹è¦æ±‚">

**åŠŸèƒ½è¦æ±‚**ï¼š
- åˆ›å»ºå›ºå®šé«˜åº¦è™šæ‹ŸåŒ–åˆ—è¡¨
- æ”¯æŒ10000+æ•°æ®é¡¹
- æµç•…çš„æ»šåŠ¨ä½“éªŒ
- å¯è§é¡¹ç›®æ•°é‡ä¼˜åŒ–

**å®ç°è¦æ±‚**ï¼š
```javascript
// éœ€è¦å®ç°çš„åŠŸèƒ½
function VirtualizedList({ items, itemHeight = 60 }) {
  // è®¡ç®—å¯è§èŒƒå›´
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(startIndex + 20, items.length);

  // æ¸²æŸ“è™šæ‹ŸåŒ–é¡¹ç›®
  return (
    <div style={{ height: 400, overflow: 'auto' }}>
      <div style={{ position: 'relative', height: items.length * itemHeight }}>
        {items.slice(startIndex, endIndex).map((item, index) => (
          <div
            key={item.id}
            style={{
              position: 'absolute',
              top: (startIndex + index) * itemHeight
            }}
          >
            <ListItem item={item} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

**æç¤º**ï¼š
- ä½¿ç”¨Math.floorè®¡ç®—èµ·å§‹ç´¢å¼•
- æ·»åŠ ç¼“å†²åŒºé˜²æ­¢é—ªçƒ
- ä½¿ç”¨absoluteå®šä½
- ä¼˜åŒ–æ»šåŠ¨æ€§èƒ½

</Expandable>

### ç»ƒä¹ 2ï¼šå®ç°åŠ¨æ€é«˜åº¦è™šæ‹ŸåŒ–

<Expandable title="ç‚¹å‡»æŸ¥çœ‹è¦æ±‚">

**åŠŸèƒ½è¦æ±‚**ï¼š
- æ”¯æŒåŠ¨æ€é«˜åº¦é¡¹ç›®
- è‡ªåŠ¨æµ‹é‡é¡¹ç›®é«˜åº¦
- å¹³æ»‘çš„æ»šåŠ¨ä½“éªŒ
- é«˜åº¦ç¼“å­˜æœºåˆ¶

**å®ç°è¦æ±‚**ï¼š
```javascript
// éœ€è¦å®ç°çš„åŠŸèƒ½
function DynamicHeightVirtualList({ items }) {
  const [itemHeights, setItemHeights] = useState({});

  // æµ‹é‡é¡¹ç›®é«˜åº¦
  const handleMeasure = (index, height) => {
    setItemHeights(prev => ({ ...prev, [index]: height }));
  };

  // è®¡ç®—ä½ç½®
  const getItemPosition = (index) => {
    // å®ç°ä½ç½®è®¡ç®—é€»è¾‘
  };
}
```

**æç¤º**ï¼š
- ä½¿ç”¨useStateå­˜å‚¨é«˜åº¦
- æµ‹é‡å›è°ƒä¼ é€’é«˜åº¦å€¼
- ç´¯ç§¯è®¡ç®—é¡¹ç›®ä½ç½®
- å¤„ç†æµ‹é‡å»¶è¿Ÿ

</Expandable>

### ç»ƒä¹ 3ï¼šå®ç°è™šæ‹ŸåŒ–è¡¨æ ¼

<Expandable title="ç‚¹å‡»æŸ¥çœ‹è¦æ±‚">

**åŠŸèƒ½è¦æ±‚**ï¼š
- æ”¯æŒå¤šåˆ—è™šæ‹ŸåŒ–
- å›ºå®šè¡¨å¤´
- è¡Œé€‰æ‹©åŠŸèƒ½
- åˆ—å®½è‡ªé€‚åº”

**å®ç°è¦æ±‚**ï¼š
```javascript
// éœ€è¦å®ç°çš„åŠŸèƒ½
function VirtualizedTable({ data, columns }) {
  return (
    <div>
      {/* å›ºå®šè¡¨å¤´ */}
      <div style={{ position: 'sticky', top: 0 }}>
        <div style={{ display: 'flex' }}>
          {columns.map(col => (
            <div key={col.key} style={{ width: col.width }}>
              {col.title}
            </div>
          ))}
        </div>
      </div>

      {/* è™šæ‹ŸåŒ–è¡Œ */}
      <div>
        {/* å®ç°è¡Œè™šæ‹ŸåŒ– */}
      </div>
    </div>
  );
}
```

**æç¤º**ï¼š
- ä½¿ç”¨stickyå®šä½è¡¨å¤´
- Flexboxå¸ƒå±€åˆ—
- è¡Œè™šæ‹ŸåŒ–ä¸åˆ—è¡¨ç±»ä¼¼
- å¤„ç†åˆ—å®½è®¡ç®—

</Expandable>

### ç»ƒä¹ 4ï¼šå®ç°èŠå¤©è®°å½•è™šæ‹ŸåŒ–

<Expandable title="ç‚¹å‡»æŸ¥çœ‹è¦æ±‚">

**åŠŸèƒ½è¦æ±‚**ï¼š
- æ”¯æŒå¤šç§æ¶ˆæ¯ç±»å‹
- æ—¶é—´æˆ³æ˜¾ç¤º
- è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
- æ¶ˆæ¯åˆ†ç»„

**å®ç°è¦æ±‚**ï¼š
```javascript
// éœ€è¦å®ç°çš„åŠŸèƒ½
function ChatVirtualList({ messages }) {
  // æ¶ˆæ¯ç±»å‹ï¼štext, image, file
  const getMessageHeight = (message) => {
    if (message.type === 'image') return 200;
    if (message.type === 'file') return 80;
    return 60;
  };

  // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
  const scrollToBottom = () => {
    // å®ç°æ»šåŠ¨é€»è¾‘
  };
}
```

**æç¤º**ï¼š
- åŒºåˆ†æ¶ˆæ¯ç±»å‹
- æ—¶é—´çº¿å¸ƒå±€
- è‡ªåŠ¨æ»šåŠ¨ä¼˜åŒ–
- åˆ†ç»„æ˜¾ç¤º

</Expandable>

---

## 11. æœ¬ç« å°ç»“

### å…³é”®è¦ç‚¹

<Checklist>

- âœ… è™šæ‹ŸåŒ–é€šè¿‡åªæ¸²æŸ“å¯è§å†…å®¹å¤§å¹…æå‡æ€§èƒ½
- âœ… å›ºå®šé«˜åº¦è™šæ‹ŸåŒ–æ¯”åŠ¨æ€é«˜åº¦æ›´ç®€å•é«˜æ•ˆ
- âœ… ç¼“å†²åŒºæœºåˆ¶é˜²æ­¢å†…å®¹é—ªçƒ
- âœ… React.memoä¸è™šæ‹ŸåŒ–ç»“åˆä½¿ç”¨æ•ˆæœæ›´ä½³
- âœ… é˜²æŠ–ä¼˜åŒ–æ»šåŠ¨äº‹ä»¶æ€§èƒ½
- âœ… ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“å¯å¿«é€Ÿå®ç°è™šæ‹ŸåŒ–
- âœ… è™šæ‹ŸåŒ–é€‚ç”¨äºå¤§æ•°æ®åˆ—è¡¨åœºæ™¯
- âœ… åŠ¨æ€é«˜åº¦éœ€è¦é¢å¤–çš„æµ‹é‡å’Œç¼“å­˜æœºåˆ¶
- âœ… æ€§èƒ½ç›‘æ§æ˜¯ä¼˜åŒ–çš„é‡è¦æ‰‹æ®µ
- âœ… æ­£ç¡®ä½¿ç”¨Keyé¿å…æ¸²æŸ“é—®é¢˜

</Checklist>

### è™šæ‹ŸåŒ–æœ€ä½³å®è·µ

<BestPractices>

1. **ä¼˜å…ˆä½¿ç”¨å›ºå®šé«˜åº¦** - æ€§èƒ½æœ€ä½³
2. **åˆç†è®¾ç½®ç¼“å†²åŒº** - å¹³è¡¡æ€§èƒ½ä¸å†…å­˜
3. **é˜²æŠ–æ»šåŠ¨äº‹ä»¶** - å‡å°‘é‡æ¸²æŸ“
4. **ä½¿ç”¨React.memo** - é¿å…ä¸å¿…è¦æ¸²æŸ“
5. **ç›‘æ§æ€§èƒ½æŒ‡æ ‡** - æŒç»­ä¼˜åŒ–
6. **é€‰æ‹©åˆé€‚åº“** - react-windowæ¨è
7. **æµ‹è¯•å¤§æ•°æ®é›†** - ç¡®ä¿æ€§èƒ½è¾¾æ ‡
8. **è€ƒè™‘SEOå½±å“** - æœç´¢å¼•æ“ä¼˜åŒ–
9. **ç§»åŠ¨ç«¯é€‚é…** - è§¦æ‘¸æ»šåŠ¨ä¼˜åŒ–
10. **ä»£ç æ¨¡å—åŒ–** - ä¾¿äºç»´æŠ¤å’Œå¤ç”¨

</BestPractices>

### ä½•æ—¶ä½¿ç”¨è™šæ‹ŸåŒ–

<BestPractices>

**å¼ºçƒˆæ¨è**ï¼š
- åˆ—è¡¨é¡¹è¶…è¿‡100ä¸ª
- DOMèŠ‚ç‚¹è¶…è¿‡500ä¸ª
- æ»šåŠ¨æ€§èƒ½ä½äº30fps
- å†…å­˜ä½¿ç”¨è¶…è¿‡50MB
- é¦–å±åŠ è½½æ—¶é—´è¶…è¿‡2ç§’

**å¯é€‰ä½¿ç”¨**ï¼š
- åˆ—è¡¨é¡¹50-100ä¸ª
- éƒ¨åˆ†å†…å®¹é«˜åº¦å¯å˜
- ç§»åŠ¨ç«¯æ€§èƒ½è¦æ±‚é«˜
- å¤æ‚åµŒå¥—å¸ƒå±€

**ä¸æ¨è**ï¼š
- åˆ—è¡¨é¡¹å°‘äº50ä¸ª
- å†…å®¹é«˜åº¦é«˜åº¦åŠ¨æ€
- éœ€è¦å®Œæ•´DOMæ“ä½œ
- SEOå…³é”®å†…å®¹

</BestPractices>

### ä¸‹ä¸€æ­¥å­¦ä¹ 

ç°åœ¨ä½ å·²ç»æŒæ¡äº†è™šæ‹ŸåŒ–æŠ€æœ¯ï¼Œæ¥ä¸‹æ¥å¯ä»¥å­¦ä¹ ï¼š

1. **[React.memoåŸºç¡€](./react-memo)** - ç»„ä»¶æ€§èƒ½ä¼˜åŒ–
2. **[ä»£ç åˆ†å‰²](../advanced/code-splitting)** - åŠ¨æ€åŠ è½½ä¼˜åŒ–
3. **[æ€§èƒ½ç›‘æ§å·¥å…·]** - æ€§èƒ½åˆ†æå®æˆ˜
4. **[Reactæ¸²æŸ“åŸç†]** - æ·±å…¥ç†è§£æ¸²æŸ“æœºåˆ¶

---

## 12. å»¶ä¼¸é˜…è¯»

### å®˜æ–¹èµ„æº

- [react-windowæ–‡æ¡£](https://react-window.now.sh/) - è½»é‡çº§è™šæ‹ŸåŒ–åº“
- [react-virtualizedæ–‡æ¡£](https://github.com/bvaughn/react-virtualized) - åŠŸèƒ½ä¸°å¯Œè™šæ‹ŸåŒ–
- [@tanstack/react-virtual](https://tanstack.com/virtual/latest) - ç°ä»£è™šæ‹ŸåŒ–åº“

### æ¨èé˜…è¯»

- [Virtual Scrolling](https://addyosmani.com/blog/virtual-scrolling/) - è™šæ‹Ÿæ»šåŠ¨æ·±åº¦è§£æ
- [Reactæ€§èƒ½ä¼˜åŒ–æŒ‡å—](https://kentcdodds.com/blog/application-state-management-with-react) - ç»¼åˆæ€§èƒ½ä¼˜åŒ–
- [Webæ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ](https://web.dev/performance/) - æµè§ˆå™¨æ€§èƒ½æŒ‡å—

### ç›¸å…³è¯é¢˜

- [React.memo](./react-memo) - ç»„ä»¶è®°å¿†åŒ–
- [useMemoå’ŒuseCallback](../hooks/advanced/useMemo) - Hookæ€§èƒ½ä¼˜åŒ–
- [ä»£ç åˆ†å‰²](../advanced/code-splitting) - åŠ¨æ€å¯¼å…¥
- [æ€§èƒ½ç›‘æ§å·¥å…·] - æ€§èƒ½åˆ†æ

---

[â† ä¸Šä¸€ç« ï¼šReact.memoåŸºç¡€](./react-memo) | [ä¸‹ä¸€ç« ï¼šä»£ç åˆ†å‰² â†’](../advanced/code-splitting)
